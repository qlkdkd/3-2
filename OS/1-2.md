 ![image](https://github.com/user-attachments/assets/a2b0f12a-0aec-4400-aaf8-01d84813e1b7)
1-16a
* A가 먼저 메모리에 적재되어 실행. 2의 시간동안 CPU작업이 진행되다가 2의 시간동안 입출력이 실행되고,
* 다시 3의 시간동안 CPU작업이 실행되고 3의 시간동안 입출력을 수행한 후, 마지막으로 3의 시간동안 CPU작업이 수행된 후 종료
* 곧바로 B가 적재되어 실행을 시작한다. B가 적재되는 시간은 무시한다.
* CPU는 B의 코드를 1의 시간동안 실행하다가 입출력이 발생하여 3의 시간동안 놀면서 대기한다.
* 그 후 1의 시간동안 실행하다가 입출력이 발생한 3의 시간을 CPU는 대기하면서 시간을 보낸 후, 2의 시간동안 코드를 실행하고 종료한다.
* 이런 식으로 C도 실행된다.
* 프로그램 A, B, C가 모두 처리되는데 총 30의 시간이 소요되었다.

1-16b
* CPU가 프로그램 A의 코드를 2의 시간동안 실행하다가 프로그램 A의 코드에서 입출력이 발생하면,
* 운영체제는 프로그램 A의 실행을 일시 중지시키고 메모리에 대기 중인 프로그램 B를 선택하고 CPU에게 실행시킨다.
* CPU가 프로그램 C의 실행을 시작한 후 1의 시간이 지날 때, 프로그램 A에서 발생시킨 IO작업이 완료되었기 때문에
* 운영체제는 프로그램C의 작업을 중단시키고 중단된 프로그램 A의 작업을 계속하여 실행시킨다.

![image](https://github.com/user-attachments/assets/709fb3e3-3655-4541-8e61-0eff8ac156e4)

### 다중 프로그래밍 도입으로 인한 이슈
* 큰 메모리 이슈
  * 여러 프로그램을 동시에 메모리에 올려놓기 위해서는 메모리의 크기 늘릴 필요
 
* 프로그램의 메모리 할당 및 관리 이슈
  * 몇 개의 프로그램 적재? 메모리 어디에 적재? 프로그램 당 할당하는 메모리 크기?
 
* 메모리 보호 이슈(Memeory Protection)
  * 프로그램이 다른 프로그램의 영역을 침범하지 못하게 막는 방법 필요
  * 해킹, 루팅 등

* CPU 스케줄링과 컨텍스트 스위칭
  * 실행시킬 프로그램 선택하는 스케줄링 필요
  * 프로그램의 실행 상태를 저장할 컨텍스트의 정의
  * 컨텍스트 스위칭 필요
  * 스케줄링

> #### 설명
> 콘텍스트는 문맥을 바꾸는 것. CPU 안에 있는 정보를 바꾸는 것
> * A가 만화책 89페이지까지를 보았다.
> * 그런데 앞에 예쁜 여학생이 지나가자 눈이 돌아갔다.
> * 여학생이 돌아간 후 A는 90페이지부터 본다

 
* 인터럽트 개념 도입
 * 운영체제가 입출력 장치로부터 입출력 완료를 전달받는 방법 필요

* 동기화(syncronization)
 * 여러 프로그램이 동일한 자원을 동시에 액세스할 때 발생하는 문제 해결
> #### 설명
> * 예를 들어 프로그램 A가 자원 R을 사용하여 자원 R의 상태를 S로 만들고 IO를 발생시키면,
> * 운영체제에 의해 일시 중단되고 프로그램 B가 실행된다.
> * 프로그램 B는 A가 R을 사용하고 있었다는 사실을 모르고 자원 R을 T상태로 만들고 사용하다가 일시 중단되고 다시 프로그램 A가 실행된다.
> * 자원 R의 상태가 프로그램 B에 의해 훼손되었기 때문에, 실행을 재개한 프로글매 A가 자원 R을 사용하여 어떤 계산을 수행하면 틀린 결과를 얻게 되는 문제가 발생한다.
> * 다중 프로그래밍의 출현으로 인해 여러 프로그램이 자원을 동시에 사용할 때 프로그램 사이의 조율이 필요한 동기화 이슈가 생겼다.

* 교착상태 해결(deadlock)
 * 프로세스들이 상대가 가진 자원을 서로 요청하면서 무한대기하는 교착상태 해결
> #### 설명
> * A와 B가 각각 자원 R1과 R2를 소유한 상태에서,
> * A는 B가 소유한 자원 R2를 요청하고,
> * B는 A가 소유한 자원 R1을 요청한다.
> * 그렇게 되면 두 프로그램은 무한정 대기하는 이른바 교착상태 발생

* 동기화 케이스
 * 동기화와 두 프로그램이 결부가되서 교착상태를 해결하는 솔루션


## 3.4. 시분할 다중 프로그래밍
* 시분할 운영체제는 여러 프로그램을 메모리에 적재하고, 1초나 100ms등 시간 할당량(타임슬라이스)을 정하여 시간 할당량만큼 메모리에 적재된 모든 프로그램에게 돌아가면서 CPU를 할당하고 실행시킨다.

![image](https://github.com/user-attachments/assets/241b5e25-99b7-4c6b-bead-032688e83a1f)

* 시분할 운영체제는 사용자 개수만큼(터미널 개수) 사용자와 대화하도록 미리 준비된 프로그램을 실행시킨다.
* 이 프로그램은 해당 터미널로부터 사용자의 명령을 받아 명령을 처리하고 결과를 터미널에 출력한 후 사용자로부터 다음 명령을 대기한다.
* 시분할 운영체제는 일정 시간 간격으로 돌아가면서 프로그램에게 CPU를 할당한다.
* CPU처리 속도는 사용자가 키를 입력하는 속도에 비교할 수 없이 빠르다.
* 그러므로 사용자가 명령을 입력하는 시간동안 CPU가 다른 사용자들로부터 들어온 명령들을 충분히 처리할 수 있기 때문에, 각 사용자는 자신이 내린 명령에 대한 응답이 늦게 온다고 여기지 않는다.

![image](https://github.com/user-attachments/assets/663d02a8-e379-4b4f-8c14-1c7d7d5a5d46)

