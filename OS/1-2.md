 ![image](https://github.com/user-attachments/assets/a2b0f12a-0aec-4400-aaf8-01d84813e1b7)
1-16a
* A가 먼저 메모리에 적재되어 실행. 2의 시간동안 CPU작업이 진행되다가 2의 시간동안 입출력이 실행되고,
* 다시 3의 시간동안 CPU작업이 실행되고 3의 시간동안 입출력을 수행한 후, 마지막으로 3의 시간동안 CPU작업이 수행된 후 종료
* 곧바로 B가 적재되어 실행을 시작한다. B가 적재되는 시간은 무시한다.
* CPU는 B의 코드를 1의 시간동안 실행하다가 입출력이 발생하여 3의 시간동안 놀면서 대기한다.
* 그 후 1의 시간동안 실행하다가 입출력이 발생한 3의 시간을 CPU는 대기하면서 시간을 보낸 후, 2의 시간동안 코드를 실행하고 종료한다.
* 이런 식으로 C도 실행된다.
* 프로그램 A, B, C가 모두 처리되는데 총 30의 시간이 소요되었다.

1-16b
* CPU가 프로그램 A의 코드를 2의 시간동안 실행하다가 프로그램 A의 코드에서 입출력이 발생하면,
* 운영체제는 프로그램 A의 실행을 일시 중지시키고 메모리에 대기 중인 프로그램 B를 선택하고 CPU에게 실행시킨다.
* CPU가 프로그램 C의 실행을 시작한 후 1의 시간이 지날 때, 프로그램 A에서 발생시킨 IO작업이 완료되었기 때문에
* 운영체제는 프로그램C의 작업을 중단시키고 중단된 프로그램 A의 작업을 계속하여 실행시킨다.

![image](https://github.com/user-attachments/assets/709fb3e3-3655-4541-8e61-0eff8ac156e4)

### 다중 프로그래밍 도입으로 인한 이슈
* 큰 메모리 이슈
  * 여러 프로그램을 동시에 메모리에 올려놓기 위해서는 메모리의 크기 늘릴 필요
 
* 프로그램의 메모리 할당 및 관리 이슈
  * 몇 개의 프로그램 적재? 메모리 어디에 적재? 프로그램 당 할당하는 메모리 크기?
 
* 메모리 보호 이슈(Memeory Protection)
  * 프로그램이 다른 프로그램의 영역을 침범하지 못하게 막는 방법 필요
  * 해킹, 루팅 등

* CPU 스케줄링과 컨텍스트 스위칭
  * 실행시킬 프로그램 선택하는 스케줄링 필요
  * 프로그램의 실행 상태를 저장할 컨텍스트의 정의
  * 컨텍스트 스위칭 필요
  * 스케줄링

> #### 설명
> 콘텍스트는 문맥을 바꾸는 것. CPU 안에 있는 정보를 바꾸는 것
> * A가 만화책 89페이지까지를 보았다.
> * 그런데 앞에 예쁜 여학생이 지나가자 눈이 돌아갔다.
> * 여학생이 돌아간 후 A는 90페이지부터 본다

 
* 인터럽트 개념 도입
 * 운영체제가 입출력 장치로부터 입출력 완료를 전달받는 방법 필요

* 동기화(syncronization)
 * 여러 프로그램이 동일한 자원을 동시에 액세스할 때 발생하는 문제 해결
> #### 설명
> * 예를 들어 프로그램 A가 자원 R을 사용하여 자원 R의 상태를 S로 만들고 IO를 발생시키면,
> * 운영체제에 의해 일시 중단되고 프로그램 B가 실행된다.
> * 프로그램 B는 A가 R을 사용하고 있었다는 사실을 모르고 자원 R을 T상태로 만들고 사용하다가 일시 중단되고 다시 프로그램 A가 실행된다.
> * 자원 R의 상태가 프로그램 B에 의해 훼손되었기 때문에, 실행을 재개한 프로글매 A가 자원 R을 사용하여 어떤 계산을 수행하면 틀린 결과를 얻게 되는 문제가 발생한다.
> * 다중 프로그래밍의 출현으로 인해 여러 프로그램이 자원을 동시에 사용할 때 프로그램 사이의 조율이 필요한 동기화 이슈가 생겼다.

* 교착상태 해결(deadlock)
 * 프로세스들이 상대가 가진 자원을 서로 요청하면서 무한대기하는 교착상태 해결
> #### 설명
> * A와 B가 각각 자원 R1과 R2를 소유한 상태에서,
> * A는 B가 소유한 자원 R2를 요청하고,
> * B는 A가 소유한 자원 R1을 요청한다.
> * 그렇게 되면 두 프로그램은 무한정 대기하는 이른바 교착상태 발생

* 동기화 케이스
 * 동기화와 두 프로그램이 결부가되서 교착상태를 해결하는 솔루션


## 3.4. 시분할 다중 프로그래밍
* 시분할 운영체제는 여러 프로그램을 메모리에 적재하고, 1초나 100ms등 시간 할당량(타임슬라이스)을 정하여 시간 할당량만큼 메모리에 적재된 모든 프로그램에게 돌아가면서 CPU를 할당하고 실행시킨다.

![image](https://github.com/user-attachments/assets/b36b2a95-4410-41c5-9b30-69af0f85e433)

* 시분할 운영체제는 사용자 개수만큼(터미널 개수) 사용자와 대화하도록 미리 준비된 프로그램을 실행시킨다.
* 이 프로그램은 해당 터미널로부터 사용자의 명령을 받아 명령을 처리하고 결과를 터미널에 출력한 후 사용자로부터 다음 명령을 대기한다.
* 시분할 운영체제는 일정 시간 간격으로 돌아가면서 프로그램에게 CPU를 할당한다.
* CPU처리 속도는 사용자가 키를 입력하는 속도에 비교할 수 없이 빠르다.
* 그러므로 사용자가 명령을 입력하는 시간동안 CPU가 다른 사용자들로부터 들어온 명령들을 충분히 처리할 수 있기 때문에, 각 사용자는 자신이 내린 명령에 대한 응답이 늦게 온다고 여기지 않는다.

![image](https://github.com/user-attachments/assets/9ac40e37-a56c-458c-b511-351def22c55e)
> * p1, p2, p3, ..., p10: 사용자 n번의 프로세스
> * 각각의 CPU를 점유하는 시간: 0.1초
>  * 그러면 프로세스 1번이 0.1초 잡고 프로세스 2번이 0.1초 잡고 3번이 0.1초 잡고... 이런 식으로 동작을 함
>  * -> 타임 셰어링
> * 3번에서 사용자가 명령을 입력함
> * 여기에서 뭔가 리스턴스가 오길 기다림
> * 근데 그 리스턴스가 오기도 전에 넘어감. 4번으로 넘어가고 있음
> * 그러고 나서 자기 다음 타임에 보니 3번에 있음.
> * 근데 끝나지 않음. 그 다음에 가서 봤더니 이제서 끝남
> * -> 만일에 p3가 타임 셰어링을 하지 않고 지금 여기서 보면 0.3초 정도가 있어야지 p3 1이 끝난다고 지금 봄.
> * 근데 CPU를 혼자 쓰는 것이 아닌 10개의 프로세스가 나누어 쓰기 때문에 사용자가 주황색 첫 번째 주황색에서 다음 p3가 p4에게 CPU를 뺏 기지 않고 계속 주구장창 CPU를 쓸 수 있었으면 0.3초만에 바로 끝남
> 
> * 그렇지만 시분할 시스템이기 때문에 다른 사람도 쓰니까 0.3초 걸리는 일을 나 쓰고 0.1초 쓰고 쭉 기다리다가 다른사람 0.1초씩 다 쓴거 기다렸다가 또 다른 놈이 0.1초씩 내 순서가 돌아옴
> * 이제 끝남

![image](https://github.com/user-attachments/assets/d97502ab-4db6-4fff-a4ff-15b5a21b0dfe)
> * a는 배치 프로세스인 경우에는 0.2초를 쓰고 IO가 0.2가 발생하게 0.3을 쓰고 0.3이 발생을 하고 이렇게 되는데 시분할에서는 0.1초씩만 쓰게 바꿈
> * 그러면 a가 0.1초 쓰고 바로 놔야 함. 그 다음에 b도 0.1초 쓰고 바로 놔야 함
> * 근데 b는 0.1초 쓰고 바로 IO 발생
> * 그래서 time2에서 보면 0.1초 쓰고 바로 IO발생함
>
> * a에서 IO가 발생하지 않은 이유:
>   * 스위칭 발생. 그러니까 0.1초를 다 쓰지 않고 0.1초만 쓰고 컨택스트 스위칭이 발생을 했기 때문에 IO가 발생을 안함.
> * 그래서 ab하고 그 다음에는 c는 b가 이제 IO 발생하는 구간에서 c는 다시 0.2초를 잡고 그 다음에 여기서도 IO가 발생하지 않음
>   * c는 0.2초 다음에 IO가 나오고 그렇게 해서 이렇게 됨
>  
> * 0.3초 구간에서 보면 a가 0.1초를 다 쓰고 바로 IO가 발생하는 b는 세 기간동안 IO가 발생을 하기 때문에
> * a가 여기에서 4번째 구간 0.4초 구간에서 CPU를 쓰고 다른놈 쓰세요라고 주려고 했더니 b는 IO상태, CPU필요 없는 상태가 됨
> * b는 계속 IO상태.
>
> * a 구간에서 a라는 녀석이 7구간에서 0.2초 잡음
>  * a구간에서 a라는 녀석이 7구간에서 CPU를 잡음. b를 찾아옴. 8로 이제 넘어갈 상때 0.1초 쓰니까 b는 IO상태가 됨.
>  * c도 IO상태임.
>  * 그래서 a가 쓰게 됨.
>
> * 맨 끝(13번째 구간)에서는 b와 c는 4번을 다 썼기 때문에 다 씀.
> * 그러면 남은 a가 전부 사용

![image](https://github.com/user-attachments/assets/a0db5336-0f72-4c70-b33e-b647a5ac0f80)

---

# 2. 컴퓨터 시스템과 운영체제
## 2-1. 컴퓨터 시스템과 하드웨어

![image](https://github.com/user-attachments/assets/d28fb53f-5da9-4c18-a408-665c583f9bb1)

* GPU는 PCIe로 연결됨.
 * 

### 컴퓨터 시스템의 범위

* 컴퓨터 시스템의 계층
  * 응용 프로그램 층
  * 운영체제 층
  * 컴퓨터 하드웨어 층ㅇ
* 컴퓨터 시스템 계층 구조의 특징
  * 사용자는 응용 프로그램과 GUI/도구 프로그램(툴/유틸리티)을 통해 컴퓨터 활용
  * 하드웨어는 모두 운영체제의 **배타적 독점적 지배**를 받음
> #### 배타적 독점적 지배
> * 하드웨어는 오로지 이 녀석한테만 지배를 받는다.
> * 사용자나 공용 프로그램은 하드웨어 체크 안됨

  * 사용자나 응용 프로그램의 하드웨어에 대한 직접 접근 불허
    * 반드시 운영체제를 통해서만 접근 가능
* 계층 구조로 보는 운영체제 기능
  * 사용자가 하드웨어에 대해 몰라도 컴퓨터를 사용할 수 있게 함
  * 응용 프로그램과 하드웨어 사이의 중계
    * 위로는 응용 프로그램과 아래로는 하드웨어와 인터페이

### 컴퓨터 하드웨어 설명
* CPU(Central Processing Unit)
 * 프로그램 코드(기계 명령)을 해석하여 실행하는 중앙 처리장치
 * 컴퓨터의 가장 핵심 장치
 * 전원이 공급될 때 작동 시작, 메모리에 적재된 프로그램 실행

* 메모리
  * CPU에 의해 실행되는 프로그램 코드와 데이터가 적재되는 공간
  * 반도체 메모리 RAM
  * 프로그램은 실행되기 위해 반드시 메모리에 적재되어야 함

* 캐시 메모리(cache memory)
 * 배경
   * cpu처리 속도가 메모리 속도에 비해 빠르게 발전-> 느린 메모리 때문에 CPU의 대기시간이 늘게 되었음
   * CPU의 프로그램 실행 속도를 높이기 위해, CPU와 메모리 사이에 소량의 빠른 메모리(고가의 메모리)를 설치하게 되었음
 * 온칩캐시(on-chip cache): CPU내부에 만들어진 캐시. 오늘날 대부분은 온칩 캐시
 * 오프칩캐시(off-chip cache): CPU 외부에 설치되는 캐시
 * 캐시 메모리가 있는 경우 CPU는 캐시 메모리에서만 프로그램 실행
   * 실행하고자 하는 프로그램과 데이터는 메모리에 먼저 적재되고 다시 캐시로 옮겨져야 함
   * 캐시는 용량이 작기 때문에 현재 실행할 코드와 데이터의 극히 일부분만 저장

![image](https://github.com/user-attachments/assets/e6d4a25b-f8e8-49d7-b8c0-c701672bf1cf)

> * A가 공부하고 있는데 의자에 앉아가지고 공부를 하고 있다. A 옆에 책장이 있고 여기 책상이 있다.
> * A는 OS공부를 하고 있는데 책장에 OS가 있다. A는 OS를 공부하기 위해 일어서서 책을 책장에 꺼내고 책상에 펼쳐서 OS공부를 한다.
> * -> 책상이 캐시고 책장을 메모리로 비유할 수 있다.
>
> * A의 엄마가 밥먹으라는 명령이 일어나자 A는 밥먹으러 나갔다.
> * A는 다시 OS공부를 하기 위해서 OS책을 펼쳐놓은 책상으로 간다.
> * -> 캐시는 원래 쓰고 있던 데이터를 참조할 때 굉장히 빠르다.
>
> * A는 시스템 프로그래밍 책을 공부하려고 한다.
> * A는 다시 책장에서 책을 꺼내고 책장에 시스템 프로그래밍 책을 핀다.
> * 책상에는 시스템 프로그래밍 책과 OS책이 펼쳐져 있다.
> * A는 또 시각지능학습을 공부하려고 책장에서 책을 꺼내서 책상에 갖다놓으려 한다.
> * 그러나 책상은 이미 꽉 찼다.
> * -> 캐시 메모리의 용량은 책상의 넓이로 비유할 수 있다.
>
> * A는 책상이 너무 작다고 생각해 책상을 100m짜리로 변경하려고 한다.
> * 책상에 책을 많이 놓을 수 있는건 좋은데 책을 찾으려면 책상 위를 걸어가야 한다.
> * -> 캐시 메모리는 용량이 너무 크면 비효율적이다. 대부분 스마트폰에 들어있는 캐시 메모리는 2Mb 정도이다.
>
> ##### 캐시리스
> * A는 시각지능학습 책과 시스템 프로그래밍 책을 펴놨는데 B와 밥먹고 왔고, B는 A가 공부하는 것을 보고 있다.
> * B는 나중에 공부해야 하는데 책상이 없다.
> * 이것을 캐시리스라 볼 수 있다.
> * 캐시가 없다면 메모리에 한 번 갔다와야 한다.
