## 3. 커널과 시스템 호출

### 응용 프로그램의 자원접근 문제
#### 오늘날 운영체제는 다중 프로그래밍 운영체제
* 다수의 응용프로그램이 한 컴퓨터에서 동시 실행

#### 문제
* 응용 프로그램이 직접 컴퓨터 자원에 접근하면 충돌과 훼손 발생
  * 다른 응용프로그램이 적재된 메모리 훼손 가능
  * 다른 응용프로그램이 만든 파일 삭제 및 훼손 가능
  * 응용 프로그램이 커널이 적재된 영역 훼손 가능
 
#### 해결 방안
* 응용프로그램의 자원 접근 불허
  * 자원에 대한 모든 접근은 커널에만 부여
 
#### 구체적인 해결 방안
1. 메모리 공간을 *사용자 공간과 커널 공간으로 분리*
* 응용프로그램은 사용자 공간에 적재, 커널은 커널 공간에만 적재
2. CPU의 실행 모드를 *사용자 모든와 커널 모드로* 분리
* 응용프로그램은 사용자 모드에서만 실행, 커널 코드는 커널 모드에서만 실행
* 사용자 공간에서 커널 공간의 코드를 직접 접근하지 못하게 하기 위해
* 사용자 모드에서 커널 코드를 접근하면 응용프로그램 강제 종료
3. 응용프로그램이 커널 기능을 이용하고자 할 때, _시스템 호출을 이용해서만 커널 코드 이용_

### 사용자 공간과 커널 공간
#### 운영체제는 컴퓨터 메모리를 두 공간으로 분리
* 사용자 공간(user space): 모든 응용프로그램들이 나누어 사용하는 공간
  * 응용프로그램들이 적재되는 공간
* 커널 공간(kernel space): 커널만 사용할 수 있는 공간
  * 커널 코드, 커널 데이터 등 커널에 의해 배타적으로 사용되는 공간
  * 디바이스 드라이버 포함

> * 32비트 컴퓨터에서 2GB이상의 프로그램 돌릴 수 있는 이유: 프로그램은 storage에 저장

#### 분리 이유
* 커널 코드와 데이터를 악의적인 응용프로그램이나 코딩 실수로부터 지키기 위함

![image](https://github.com/user-attachments/assets/62a724ee-6d66-4e7f-a3c0-93f1cbbaeb90)

### 사용자 공간 크기
#### 사용자 공간 크기
* 한 응용프로그램의 최대 크기 결정
  * 프로그램(코드) + 데이터(전역변수) + 힙(동적할당) + 스택 합친 크기
  * 예) 32비트 윈도우 운영체제에서 사용자공간 2GB란-> 응용프로그램을 2GB크기 이상 개발할 수 없음

#### 사용자 공간의 주소 범위
* 응용프로그램은 운영체제가 설정한 사용자 공간의 주소 범위를 넘어설 수 없음
  * 예) 32비트 윈도우 운영체제에서, 응용프로그램은 $0_{16}~7FFFFFFF_{16}$범위의 주소를 넘어 액세스하면, 바로 종류(심각한 오류)
 
### 주소 공간은 가상 주소 공간
![image](https://github.com/user-attachments/assets/bc0222a2-fc24-4ca2-92f4-c9bde55f83d2)

* 주소 공간=사용자 공간+커널 공간
* 주소 공간은 가상 주소 공간
  * 물리 메모리의 주소 범위와 무관
 
* 가상 주소 공간
  * **사용자나 응용프로그램 관점에서** 보는 주소 범위
  * 사용자가 전체 메모리를 사용하고 있다고 착각
 
* 각 응용프로그램
  * 2GB의 사용자 주소 공간을 가짐
  * 사용자 코드와 데이터 최대 2GB
  * 0~7FFFFFFF의 2GB의 메모리 독점 사용 착각
 
* 커널 공간 - 2GB~4GB-1의 주소 범위
  * 8000000~FFFFFFF범위 주소 공간
  * 모든 응용프로그램은 **커널 공간 공유**
 
#### 2가지 의문
* 응용프로그램의 **사용자 공간 충돌?**
* 실제 물리 메모리가 **4GB보다 작은 경우** 어떻게?

![image](https://github.com/user-attachments/assets/575057ac-48a5-4489-a825-a83b4cd1d826)

> * 예를 들어 구세대 스마트폰 메모리를 생각해 보자.
> * 그당시 메모리는 256MB정도 되었을 것이다.
> * 여기에 512MB짜리 게임, 512MB짜리 인스타, 그리고 256MB짜리 넷플릭스를 실행시키고자 한다.
> * 그러면 컴퓨터에서는 프로그램들을 100MB씩 쪼개서 돌릴 것이다.
> * 이때 메모리에서 커널 공간을 156MB정도, 나머지는 사용자 공간으로 쓸 것이다.
> * 만약에 메모리의 크기가 더 컸더라면 프로그램의 용량을 쪼개는 정도는 더 줄어들거나 아예 쪼개지 않고 메모리에 올릴 수 있었을 것이다.
> * 메모리가 클수록 컴퓨터의 속도는 더욱 빨라진다.

### 2가지 의문에 대한 해결
#### **사용자 공간의 충돌 해결)** 가상 주소 공간을 물리 메모리에 매핑
* 각 응용프로그램의 가상 주소 공간을 물리 주소 공간으로 매핑
  * 매핑 테이블은 운영체제가 소유하고 관리
 
* 물리 메모리를 여러 응용프로그램의 사용자 공간이 나누어 사용
  * 실제 각 응용프로그램은 사용자 공간의 일부만 사용
 
* 커널 공간 역시 물리 메모리에 매핑
  * 각 응용프로그램의 매핑 테이블에 기록
  * 커널 공간에 대한 매핑 테이블 부분을 모든 응용프로그램에서 동일
 
#### **물리 메모리가 작은 경우에 대한 해결**: 물리 메모리가 부족하면
* 운영체제는 물리 메모리를 하드 디스크에 저장하여 물리 메로리의 빈 영역 확보(가상 메모리 기법)

![image](https://github.com/user-attachments/assets/4af90bfe-4b29-45dc-9660-58e74cfa1934)

![image](https://github.com/user-attachments/assets/6504a754-0b9a-4243-bfed-b00e6cdb0b1a)

### 사용자 모드와 커널 모드
#### CPU는 사용자 모드와 커널 모드 중 한 모드로 실행
* CPU내부에 모드 상태를 나타내는 '모드 레지스터'가 있음
#### 사용자 모드(user mode)
* CPU의 모드 비트: 1
* CPU는 사용자 공간에 있는 코드나 데이터를 액세스 하는 중
* CPU의 커널 공간 접근 불허-> 응용 프로그램으로부터 커널 영역 보호
* 특권 명령(privileged instruction)실행 불허
  * 특권 명령 - 입출력 장치 등 하드웨어나 시스템 중단 등 시스템 관련 처리를 위해 설계된 특별한 명령
 
#### 커널 모드(kernel mode, supervisor mode)
* CPU의 모드 비트=0
* CPU가 커널 공간에서 실행하는 중, 혹은 사용자 코드를 실행하는 중
* 특권 명령 사용 가능

### 사용자 모드와 커널 모드에서의 메모리 액세스
![image](https://github.com/user-attachments/assets/bd5a9f86-bdd7-41cf-9293-4dba80207041)

### 사용자 모드에서 커널 모드로 전환
#### 사용자 모드에서 커널 모드로 전환하는 경우
* 오직 2가지 경우 - 시스템 호출과 인터럽트 발생

#### 시스템 호출
* 시스템 호출을 실행하는 특별한 기계 명령에 의해 진행
  * 예) int 0x80/sysenter/trap/syscall 등 CPU마다 다름
* 기계명령이 CPU의 모드 비트를 커널 모드로 전환

#### 인터럽트
* CPU가 인터럽트를 수신하면 커널 모드로 자동 전환
  * 인터럽트 서비스 루틴이 커널 공간에 있기 때문
 
* CPU는 인터럽트 서비스 루틴 실행
* 인터럽트 서비스 루틴이 끝나면 CPU는 사용자 모드로 자동 전환

![image](https://github.com/user-attachments/assets/845044c4-ff69-40c8-a8df-6fd87f328c9a)

![image](https://github.com/user-attachments/assets/0f243630-bf3d-4cde-a6f8-bb80705063dd)

### 커널의 실체
#### 커널은 부팅 시에 커널 공간에 적재된 함수들과 데이터 집힙
* 커널은 컴파일된 바이너리 형태, 하드디스크 특정 영역에 저장, 부팅 시에 커널 공간의 메모리에 적재

#### 커널 코드는 함수들의 집합
* 커널의 존재 - 커널 모드에서 실행되는 함수들과 데이터들의 집합

![image](https://github.com/user-attachments/assets/9436ae05-4e10-404e-8822-912a76f67831)

#### 커널은 스스로 실행되는 프로세스인가? NO
* **커널은 함수들의 단순 집합, 시스템 호출을 통해 호출되는 함수들**
* 커널이 스케줄링한다(X)
  * 커널 프로세스가 실행되면서 주기적으로 스케줄링한다(X)
  * 시스템 호출과 인터럽트 서비스 루틴에 의해 커널 내 스케줄러 함수가 호출되어 실행(O)
#### 커널은 실행 중이다? NO
* 커널은 프로세스도 스레드도 아니므로 NO
* 커널이 실행 중이다(X)
  * 응용 프로그램이 시스템 호출을 하여 커널 코드를 실행해고 있다.(O)
  * 인터럽트가 발생하여 인터럽트 서비스 루틴이 실행되고 있다.(O)
 
#### 커널은 스택이나 힙을 가지는가? NO
* 커널은 스탭이나 힙을 가지는 주체가 아니다. 그러므로 NO
* 스택이나 힙을 가지는 주체는 프로세스나 스레드
* 스레드마다 사용자 스택과 커널 스택 소유
  * 스레드가 생성될 때 프로세스의 사용자 공간에 사용자 스택 할당
    * 사용자 코드가 실행되는 동안 활용
  * 스레드가 생성될 때 커널 공간에 커널 스택 할당
    * 스레드가 시스템 호출로 커널 코드를 실행할 때 스택으로 활용
   
### 응용 프로그램 빌딩
#### 라이브러리(library)
* 응용 프로그램에서 활용하도록 미리 작성된 함수들, 컴파일되어 바이너리 형태로 제공되는 파일
* 개발자는 라이브러리 활용 없이 응용프로그램 작성 불가능

#### 응용프로그램이 활용하는 라이브러리는 2가지 유형
* 표준 라이브러리
  * 사용자가 작성하기 힘든 함수 제공
  * 운영체제나 컴퓨터 하드웨어에 상관없이 이름과 사용법 동일
    * 운영체제나 하드웨어, 컴파일러에 관계없이 호환
   
* 시스템 호출 라이브러리(System Call Library)
  * 시스템 호출 함수들 포함
  * 시스템 호출 함수들은 시스템 호출을 진행하여 커널 모드로 바꾸고 커널로 진입하여 커널에 만들어진 함수 실행(커널의 다양한 기능 수행)
  * 운영체제마다 시스템 호출 함수의 이름이 서로 다름
    *운영체제 비호환
  * 시스템 호출 함수를 커널 API(Application Programming Interface)라고 부름
 
### 사용자 코드와 라이브러리 코드의 링킹
#### 실행 파일이 만들어지는 과정
* 응용프로그램 코드는 라이브러리 코드와의 링킹을 거쳐 하나의 실행 파일로 만들어짐

#### 응용 프로그램 실행
* 응용 프로그램이 사용자 공간에 적재
  * 실행 파일 내 사용자 코드와 라이브러리 코드의 메모리 적재
  * 실행 파일 내 사용자 전역 변수와 라이브러리의 전역변수 모두 메모리 적재
* 응용 프로그램은 사용자 모드로 실행 시작

### 응용 프로그램을 구성하는 사용자 코드와 라이브러리, 그리고 커널
![image](https://github.com/user-attachments/assets/fdb343e9-aa55-40a5-87b8-cb6b78ec3ba3)
> * 이 응용프로그램은 사용자가 작성한 main(), f(), g(), u()함수와 이들에 의해 호출되는 printf(), strcpy(), abs(), write(), open() 5개 라이브러리 함수들로 구성된다.
> * 사용자가 작성한 함수들은 **함수 호출(function call)** 을 통해 사용자가 작성한 다른 함수나 라이브러리 함수를 호출하고, 시스템 호출 라이브러리 함수들은 **시스템 호출(System call)** 을 통해 커널 코드를 활용한다.
> * 표준 라이브러리 함수들이 입출력 등 커늘의 도움이 필요할 때 시스템 호출 함수를 호출한다.

### 함수 호출과 시스템 호출
#### 함수 호출(fanction call)로 라이브러리 활용
 * 사용자 공간에 적재된 함수가 사용자 공간에 적재된 다른 함수(표준 라이브러리나 시스템 호출 라이브러리의 함수 포함)호출
 * 사용자 공간에서, 사용자 모드에서 실행
* 함수 호출 과정
 * 사용자 공간의 스택에 돌아올 주소, 매개별수 전달, 호출된 함수의 지역변수 생성
 * 사용자 공간에 적재된 함수의 주소로 점프
 * 함수가 끝나면 함수를 호출한 곳으로 복귀

#### 시스템 호출(system call)로 커널 코드 실행
 * 응용 프로그램이 운영체제의 기능을 사용하고자 할 때, 커널에 작성된 함수 실행
 * 시스템 호출 라이브러리에 포함된 시스템 호출 함수가 시스템 호출 일으킴
* 시스템 호출 과정
  * 시스템 호출을 일으키는 특별한 기계 명령 실행
  * 이 명령이 사용자 모드에서 커널 모드로 전환, 커널 함수마다 매겨진 고유 번호 전달
  * 커널의 시스템 호출 핸들러 실행
  * 시스템 호출 핸들러가 전달받은 커널 함수의 고유 번호 분석, 해당 커널 함수 호출
  * 커널 함수에서 리턴할 때 사용자 모드로 전환, 사용자 프로그램으로 복귀귀

### 응용프로그램에서 라이브러리와 커널 코드 호출 사례
![image](https://github.com/user-attachments/assets/ae104103-9542-4062-9aac-bb6106e86f84)
> * main()함수가 표준 라이브러리의 printf()함수를 호출한다.
> * printf()함수는 상황에 따라 시스템 호출을 일으키는 write()함수를 호출할 수 있고 안할 수도 있다.
> * printf()함수가 write()함수를 호출하지 않고 리턴하면 main()은 다시 f()를 호출하고 함수 f()는 표준 라이브러리의 abs()코드를 호출한다.
> * 다시 돌아오면 f()는 g()함수를 호출하고, g()함수는 u()함수를 호출한다.
> * u()함수는 파일을 열기 위해 시스템 호출 함수 open()을 호출한다.
>
> * open()은 표준 라이브러리의 함수들과 달리 '시스템 호출'을 유발시킨다.
> * 그 결과 CPU가 커널 모드로 바뀌고 파일을 여는 커널 함수의 고유 ID(시스템 호출 번호)가 시스템 호출 핸들러에게 전달된다.
> * 시스템 호출 핸들러는 시스템 호출 번호를 이용하여 파일을 여는 커널 함수를 호출하게 되며 이 함수가 커널 내 다른 함수를 호출하는 등 파일 열기를 마치고 리턴할 때 사용자 모드로 바뀌어 open()함수로 돌아온다.
>
> * printf()함수의 실행 과정은 좀 더 복잡하다.
> * 디스플레이에 출력하는 작업은 커널에 의해서만 가능하므로 printf()함수는 필요한 경우 시스템 호출 라이브러리에 포함된 write()를 호출하며 write()가 '시스템 호출'을 통해 디스플레이에 출력하는 커널 함수를 호출한다.

### 시스템 호출
#### 시스템 호출
* 사용자 공간의 코드에서 커널 서비스를 요청하는 과정
  * 사용자 공간의 코드에서 커널 서비스를 요청하는 과정
  * 커널 콜(kernel call), 트랩(trap)로도 불림
  * 응용프로그램에서 커널 기능을 활용하도록 만들어 놓은 기능
 
* 운영체제는 시스템 호출 라이브러리 제공
  * 시스템 호출 함수 혹은 커널 API 포함
  * Unix/Linux의 커널 API - open(), read(), write(), fork(), exit()
  * Windows의 커널 API - CreateProcess(), WaitFOrSingleObject()
  * 대략 200개 이상의 시스템 호출 함수 있음
 
#### 시스템 호출을 일으키는 기계 명령
* CPU마다 시스템 호출을 실행하는 특별한 기계 명령 제공
  * 시스템 호출 CPU 명령
* 사례
  * int 0x80: 인텔의 x86계열의 CPU, 32비트에서 사용
  * syscall/sysret: ADM에서 최초 구현, 64비트에서만 작동
  * sysenter/sysxit: Intel에서 최초 구현, X86/64 CPU, AMD

#### 표준 라이브러리를 통해 간접적으로 이루어지는 시스템 호출
* 응용 프로그램 -> 시스템 호출 라이브러리의 시스템 호출 함수 -> 시스템 호출 CPU 명령
* 응용 프로그램 -> 표준 라이브러리 함수 -> 시스템 호출 라이브러리의 시스템 호출 함수 -> 시스템 호출 CPU 명령

### 시스템 호출 과정 사례
![image](https://github.com/user-attachments/assets/e9c5e75f-feda-4d27-8d4e-f307247e017e)

![image](https://github.com/user-attachments/assets/d19a340f-a7f0-4405-b224-30b938668217)

![image](https://github.com/user-attachments/assets/2f57c32f-1115-424f-8eeb-8bda4837a91f)

![image](https://github.com/user-attachments/assets/3f91236a-899a-4f2d-b2a0-c64fd1b6b61f)

### 시스템 호출 비용: fread()와 read()의 비교
#### 시스템 호출은 함수 호출에 비해 많은 시간 비용
* 시스템 호출을 많이 할수록 프로그램 실행 속도 저하
#### 파일에서 1000바이트를 읽는 2가지 유형의 코드. 실행 비교 결과는?
![image](https://github.com/user-attachments/assets/5db27538-2845-4d8e-a19a-5b9ffefaf72e)

#### 표준 C 라이브러리 함수 fread()와 시스템 호출 read() 실행 비교
* 표준 C 라이브러리 함수, fread(fp, buf, size)의 동작 과정
  * fread()를 처음 호출하면 라이브러리 내 버퍼가 비어있음
  * read()를 호출하여 라이브러리 내 버퍼를 채운다. n=read(fd, buf, BLKSIZE);
  * 응용프로그램으로부터 요청 받은 크기(size)만큰 응용프로그램의 buf로 복사
  * 라이브러리 버퍼가 비거나 부족하면 그때 다시 read() 호출
 
* 시스템 호출 함수, read(fd, buf, size)의 동작 과정
  * 시스템 호출을 이용하여 커널 코드 실행
  * 커널 코드에서 디스크 읽기
  * 라이브러리를 거치지 않고 바로 buf로 읽어들임
 
![image](https://github.com/user-attachments/assets/6faa2861-c73f-418b-af81-9ae9755336c1)

> (a)
> * C 표준 라이브러리 함수 fread()를 사용하는 경우로, fread()가 처음 호출되면 fread()는 표준 라이브러리 내의 입력 버퍼를 살펴본다.
> * 처음이라 버퍼가 비어 있으므로 fread()는 read()함수를 호출하여 디스크 블록 크기(보통 4kb)만큼 파일에서 읽어오도록 지시한다.
> * read()함수는 시스템 호출을 통해 커널 함수(예: sys_read())를 호출하고, 커널 함수(sys_read())는 요청된 바이트(4kb)만큼 파일에서 읽어 라이브러리의 이력 버퍼에 저장한다.
> * fread()로 돌아오면, fread()는 표준 라이브러리의 입력 버퍼에서 100바이트를 사용자 코드의 buf[]배열로 복사하고 리턴한다.
>
> * 그러고 나면 사용자 코드의 for문에서 fread()가 2번째 호출될 때부터 9번을 계속하여 표준 라이브러리의 입력 버퍼에서 buf[]배열에 저장한다.
> * 이런 식으로 10번 모두 시스템 호출이 이루어진다.

> (b)
> * 사용자 코드 for문에서 read()가 호출되면, read()는 시스템 호출을 통해 커널 함수 (sys_read())를 호출한다.
> * 커널 함수(sys_read())는 요청받은 100바이트를 파일에서 읽어 사용자 코드의 buf[]배열에 저장한다. 이런 식으로 10번 모두 시스템 호출이 이루어진다.

> * 표준 라이브러리 함수 fread()()를 이용하는 경우 시스템 호출은 처음 1번만 일어나지만, read()를 사용하는 경우 매번 시스템 호출이 일어난다.
> * 시스템 호출에는 긴 시간이 걸리므로 사용자 프로그램에서 read()를 직접 호출하는 것은 상대적으로 실행시간이 길어 좋지 않은 코드이다.

![image](https://github.com/user-attachments/assets/c5279f0c-deb6-4510-9af2-64907f854406)
