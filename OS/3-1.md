# 3. 프로세스와 프로세스 관리

## 3-1. 프로세스 개요
### 프로세스 개요
#### 프로그램
* 하드디스크 등 저장 매체에 저장. 실행 파일의 형태

#### 프로세스
* 프로그램이 메모리에 적재되어 실행 중인 되는 상태
  * 필요한 모든 자원 할당받음
  * 자원: 코드 공간, 데이터 공간, 스택 공간, 힙 공간
> * 코드 공간과 데이터 공간은 스토리지에 저장이 되고, 스택 공간과 힙 공간은 메모리 공간에 저장된다.
> * 스택 공간과 힙 공간은 동적으로 프로그램이 프로세스화되고 실행이 될 때 생긴다.

* 프로세스의 특징
  * 운영체제는 **프로그램을 메모리에 적재**하고 프로세스를 다룸
  * 운영체제는 프로세스에게 실행에 필요한 메모리 할당, **이곳에 코드와 데이터 등 적재**
  * 프로세스들은 **서로 독립적인 메모리 공간을 가짐.** 다른 프로세스의 영역에 접근 불허
  * 운영체제는 프로세스마다 고유한 번호(프로세스 ID, PID) 할당
  * 프로세스의 관한 모든 정보는 커널에 의해 관리
  * 프로세스는 실행-대기-잠자기-대기-실행-종료 등의 생명 주기를 가짐
  * 프로세스 생성, 실행, 대기, 종료 등의 모든 관리는 커널에 의해 수행
 
![image](https://github.com/user-attachments/assets/0c861306-f2b5-4662-ae26-35771df70913)

### 프로그램과 프로세스
* 프로세스들은 상호 독립적인 메모리 공간에서 실행

![image](https://github.com/user-attachments/assets/10a4b863-6835-4955-9856-d9d1fe827520)
> * 노트패드라는 프로그램은 하드디스크에 코드 데이터가 있음
> * 운영체제 커널에 의해 코드와 데이터 등이 일단 스토리지에 있던 것들이 복사되서 메모리에 올라옴
> * 그 다음 노트패드가 실행을 하게 되면 스택과 힙을 잡아서 쓰게 됨.
> * 만약 CPU를 노트패드가 점유를 하고 있으면 크롬 프로세스와 putty프로세는 어떤 메모리에서 대기를 하게됨
> * 왜냐하면 CPU를 만일에 노트패드가 끝나면 크롬이 잡으면 노트패드는 실행될 수가 없음
> * CPU는 한순간에 하나의 프로세스밖에 실행을 못함/
> * 그리고 이렇게 각각 프로그램들이 프로세스화돼서 메모리에 올라오므로 메모리가 충돌할 일이 없음 -> 서로 독립적인 공간에서 작업을 하게 됨

### 프로세스 관리
* 프로세스의 생성에서 종료까지, 관리는 모두 커널에 의해 이루어짐
  * 커널 영역에 프로세스 테이블을 만들고, 프로세스들 목록 관리
* 관리 내용
  * 프로세스 생성, 실행, 일시 중단 및 재개, 정보 관리, 프로세스 통신, 프로세스 동기화, 프로세스 중단, 프로세스 컨텍스트 스위칭
 
![image](https://github.com/user-attachments/assets/cb2894b6-4f73-40c6-a458-6d81b3c8d29f)

![image](https://github.com/user-attachments/assets/6c26f108-e3b2-4cc6-ae6d-5086845915a2)

### 프로그램의 다중 인스턴스
#### 한 프로그램을 여러 번 실행시키면 어떻게 될까?
* 프로그램 실행 시 마다 독립된 프로세스 생성-> 프로세스들을 프로그램의 **다중 인스턴스**라고 부름
  * 각 프로세스에게 독립된 메모리 공간 할당
  * 각 프로세스를 별개의 프로세스로 취급
 
![image](https://github.com/user-attachments/assets/c5c3d427-60fa-4f3a-a256-6b3f5ec979bc)

> * Windows에서 사용자가 메모장 프로그램을 3번 실행 시켰을 때, 노트패드 프로세스가 3개 생성된 모양
> * 이들은 서로 다른 프로세스 번호를 부여받고, 서로 다른 메모리 공간에 적재되는 등 커널에 의해 완전히 별개의 프로세스들로 다루어짐

### CPU주소 공간
#### CPU 주소 공간(CPU address space)
* CPU가 주소선을 통해 액세스할 수 있는 전체 메모리 공간
* 공간 크기
  * CPU 주소선의 수에 의해 결정
* 32비트 CPU -> 32개의 주소선 -> $2^32$개의 주소 -> $2^32$바이트 -> 4GB공간
  * 1번지의 저장 공간 크기는 1바이트
  * 주소 공간은 0번지부터 시작 \~
 
* CPU주소 공간보다 큰 메모리? 있어도 액세스 불가능
* CPU주소 공간보다 작은 양의 메모리? 가능
  * 예: 32비트 CPU를 가진 컴퓨터(4GB까지 메모리 액세스 가능)에 2GB의 메모리가 설치되어 있을 때 2GB를 넘어서 액세스하면 없는 메모리를 액세스하므로 심각한 오류 발생
 
### 프로세스 구성 - 4개의 메모리 영역

![image](https://github.com/user-attachments/assets/ea727629-55be-47a7-a508-9a0368e31033)
![image](https://github.com/user-attachments/assets/ecd9cbc8-4d02-4c6a-8dcc-96bc6a084410)

1. 코드 영역
* 실행될 프로그램 코드가 적재되는 영역
  * 사용자가 작성한 **모든 함수의 코드**
  * 사용자가 호출한 라이브러리 함수들의 코드
 
2. 데이터 영역
* 프로그램에서 고정적으로 만든 변수 공간
  * 전역 변수 공간, 정적 데이터 공간
  * 사용자 프로그램과 라이브러리 포함
* 프로세스 적재 시 **할당**, **종료** 시 소멸

3. 힙 영역
* 프로세스의 실행 도중 동적으로 사용할 수 있도록 할당된 공간
  * malloc() 등으로 할당받는 공간은 힙 영역에서 할당
  * 힙 영역에서 아래 번지로 내려가면서 할당
 
4. 스택 영역
* 함수가 실행될 때 사용될 데이터를 위해 할당된 공간
  * 매개변수들, **지역변수들**, 함수 종료 후 돌아갈 주소 등
  * 함수는 호출될 때, 스택 영역에서 위쪽으로 공간 할당
  * 함수가 return하면 할당된 공간 반환
* 함수 호출 외에 프로세스에서 필요 시 사용 가능

### 프로세스 주소 공간
#### 프로세스 주소 공간
* 프로세스가 실행 중에 접근할 수 있도록 허용된 주소의 최대 범위
* 프로세스 주소 공간은 논리 공간(가상 공간)
  * 0번지에서 시작하여 연속적인 주소
 
#### 프로세스 주소 공간의 크기
* CPU가 액세스할 수 있는 전체 크기
  * 32비트 CPU의 경우 4GB(윈도우, 리눅스 모두 동일)
  * 프로세스 주소 공간 크기는 프로세스의 현재 크기와 다름
 
* 프로세스 주소 공간의 크기
  * 프로세스가 액세스할 수 있는 최대 크기(32비트 CPU의 경우 4GB)
 
* 프로세스의 크기
  * 적재된 코드+전역변수+힙 영역에서 현재 할당받은 동적 메모리 공간+스택 영역에 현재 저장된 데이터 크기
 
![image](https://github.com/user-attachments/assets/7e50247e-a3f9-4007-8eb8-8ae96f4294b5)

### 프로세스의 사용자 공간과 커널 공간
#### 프로세스 주소 공간 = 사용자 공간 + 커널 공간
* 사용자 공간
  * 프로세스의 코드, 데이터, 힙, 스택 영역이 순서대로 할당되는 공간
  * 코드와 데이터 영역의 크기는 프로세스 적재 시 결정,
  * 힙은 데이터 영역 바로 다음부터 시작하고,
  * 스택은 사용자 공간의 바닥에서 시작하여거꾸로 자람
  * 힙 영역은 높은 번지로 자라고, 스택은 낮은 번지로 자람
    * 예: 처음 malloc(100)으로 동적 할당받는 공간은 데이터 영역 바로 다음의 힙 시작부분부터 할당
    * 예: 처음 함수가 호출될 때 스택 공간은 스택 영역 바닥부터 위로 할당
   
* 커널 공간
  * 프로세스가 시스템 호출을 통해 이용하는 커널 공간
  * 커널 코드, 커널 데이터, 커널 스택(커널 코드가 실행될 때)이 존재
#### 결론
* 프로세스의 코드와 데이터는 실행 파일에 결정된 상태로코드 영역과 데이터 영역에 적재 -> 실행 중에 크기가 변하지 않음
* 프로세스는 사용자 공간의 최대 범위까지 동적할당 받으면서 힙 영역과 스택 영역을 늘려갈 수 있음

![image](https://github.com/user-attachments/assets/a2cb12a4-4d51-4eb6-9209-2adb7f501e40)

### 커널 공간의 의미

![image](https://github.com/user-attachments/assets/7e131abc-94ef-4f13-bb6c-c2b9f4477d5d)

#### 각 프로세스는
* 독립된 사용자 공간 소유
* 커널 공간 공유

#### 커널 공간
* 프로세스가 사용자 코드에서 **시스템 호출**을 통해 커널 코드 실행할 때 커널 공간 사용
  * 커널 코드를 실행하고 있는 것은 사용자 프로세스
     * *'사용자 프로세스가 커널 모드에서 실행되고 있다'* 고 표현
  * 커널 코드가 적재된 물리 메모리의 위치 역시 사용자 프로세스가 소유한 매핑 테이블 사용
     * 사용자 영역과 커널 영역을 하나의 가상 주소 영역으로 다룬다는 의미
   
#### 사용자 공간과 커널 공간의 결론
* 프로세스마다 각각 사용자 주소 공간이 있다.
* 시스템 전체에는 하나의 **커널 주소 공간**이 있다.
* 모든 프로세스는 커널 주소 공간을 공유한다.

### 프로세스의 주소 공간은 가상 주소 공간
#### 프로세스의 주소 공간은 가상 공간
* 프로세스가 사용하는 주소는 **가상 주소**이다.
  * 프로세스에서 0번지는 가상 주소 0번지
     * 물리 메모리의 0번지 아님
  * 가상 주소는 0번지부터 시작
  * 프로세스 내의 코드 주소, 전역변수에 대한 주소, malloc()에 의해 리턴된 주소, 스택에 담긴 지역 변수의 주소는 모두 **가상 주소**
 
* 프로세스의 주소 공간(가상 주소 공간)은 사용자나 개발자가 보는 관점
  * 사용자나 개발자는 프로그램이 *0번지부터* 시작하여,
  * *연속적인* 메모리 공간에 형성되고,
  * 최대 크기의 메모리가 설치되어 있다고 상상
 
* 실제 상황
  * 설치된 무리 메모리의 크기는 주소 공간보다 작을 수 있고,
  * 프로세스의 코드, 데이터, 힙, 스택은 물리 메모리에 흩어져 저장됨
    * 연속적인 메모리 공간 아님
   
![image](https://github.com/user-attachments/assets/e524cb98-5635-4e43-833f-e59f6ee7164c)

> * 운영체제는 그림과 같이 프로세스의 각 영역들을 물리 메모리의 비어 있는 공간에 나누어 적재하고는 적재된 물리 주소를 매핑 테이블에 적는다.
> * 매핑 테이블은 프로세스를 생성할 때 프로세스마다 한 개씩 만든다.
> * 프로세스가 실행된 떄 가상 주소는 매핑 테이블을 통해 물리 주소로 바뀌고 물리 메모리가 액세스된다.
> * 그림에서 프로세스의 코드들은 실제로 물리 메모리 0x12340000번지부터 적재되어 있고, 그 주소가 매핑 테이블에 기록되어 있다.
> * 프로세스가 0번지(가상주소 0번지)의 코드를 액세스하면 가상 주소 0번지는 매핑 테이블에 의해 0x12340000번지의 물리 주소로 변환되고 이 주소가 물리 메모리로 전달되어, 물리 메모리 0x12340000번지에 적재된 코드가 CPU로 전달된다.
> * 또한 프로그램 내 변수 n의주소가 3000번지라고 할 때 3000은 가상 주소다.

### 프로세스의 주소 공간은 가상 주소 공간
#### 프로세스의 주소 공간은 *가상 주소 공간*
* 프로세스의 주소 공간은 사용자나 개발자가 보는 관점
  * 자신이 작성한 프로그램이 *0번지부터* 시작하여,
  * *연속적인* 메모리 공간에 형성되고,
  * CPU마다 액세스할 수 있는 최대 크기의 메모리가 설치되어 있다고 상상
* 실제 상황
  * 설치된 물리 메모리의 크기는 주소 공간보다 작을 수 이쏙,
  * 프로세스의 코드, 데이터, 힙, 스택은 물리 메모리에 흩어져 저장됨.
    * 연속적인 메모리 공간이 아님
   
#### 프로세스 주소 공간은 각 프로세스마다 주어지는가? 예
* 프로세스마다 주소 공간은 별개이다.
#### 그러면, 프로세스 주소 공간은 충돌하는가? 아니오
* 프로세스 주소 공간은 가상 주소 공간이며,
* 가상 주소가 물리 주소로 매핑되므로, 물리 메모리에서는 충돌하지 않는다.

![image](https://github.com/user-attachments/assets/f2c00f1f-fd42-4a8a-a779-f450013a4a95)

![image](https://github.com/user-attachments/assets/fb04858b-163a-4d91-a26c-db357cc2e78d)

## 3-2. 커널의 프로세스 관리

### 프로세스 테이블과 프로세스 제어 블록
#### 프로세스 테이블(Process Table)
* 시스템의 모든 프로세스들을 관리하기 위한 표
* 시스템에 한 개만 있음
* 구현 방식은 운영체제마다 다름

#### 프로세스 제어 블록
* 프로세스에 관한 정보를 저장하는 구조체
* 프로세스당 하나씩 존재
* 프로세스가 생성될 때 만들어지고 종료되면 삭제
* 커널에 의해 생성, 저장, 읽혀지는 등 관리

#### 프로세스 테이블과 프로세스 제어 블록의 위치
* 커널 영역, 커널 코드(커널 모드)만이 액세스 가능

![image](https://github.com/user-attachments/assets/05634b6f-835e-4cb8-ba8a-53914f7f6351)

