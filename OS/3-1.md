# 3. 프로세스와 프로세스 관리

## 3-1. 프로세스 개요
### 프로세스 개요
#### 프로그램
* 하드디스크 등 저장 매체에 저장. 실행 파일의 형태

#### 프로세스
* 프로그램이 메모리에 적재되어 실행 중인 되는 상태
  * 필요한 모든 자원 할당받음
  * 자원: 코드 공간, 데이터 공간, 스택 공간, 힙 공간
> * 코드 공간과 데이터 공간은 스토리지에 저장이 되고, 스택 공간과 힙 공간은 메모리 공간에 저장된다.
> * 스택 공간과 힙 공간은 동적으로 프로그램이 프로세스화되고 실행이 될 때 생긴다.

* 프로세스의 특징
  * 운영체제는 **프로그램을 메모리에 적재**하고 프로세스를 다룸
  * 운영체제는 프로세스에게 실행에 필요한 메모리 할당, **이곳에 코드와 데이터 등 적재**
  * 프로세스들은 **서로 독립적인 메모리 공간을 가짐.** 다른 프로세스의 영역에 접근 불허
  * 운영체제는 프로세스마다 고유한 번호(프로세스 ID, PID) 할당
  * 프로세스의 관한 모든 정보는 커널에 의해 관리
  * 프로세스는 실행-대기-잠자기-대기-실행-종료 등의 생명 주기를 가짐
  * 프로세스 생성, 실행, 대기, 종료 등의 모든 관리는 커널에 의해 수행
 
![image](https://github.com/user-attachments/assets/0c861306-f2b5-4662-ae26-35771df70913)

### 프로그램과 프로세스
* 프로세스들은 상호 독립적인 메모리 공간에서 실행

![image](https://github.com/user-attachments/assets/10a4b863-6835-4955-9856-d9d1fe827520)
> * 노트패드라는 프로그램은 하드디스크에 코드 데이터가 있음
> * 운영체제 커널에 의해 코드와 데이터 등이 일단 스토리지에 있던 것들이 복사되서 메모리에 올라옴
> * 그 다음 노트패드가 실행을 하게 되면 스택과 힙을 잡아서 쓰게 됨.
> * 만약 CPU를 노트패드가 점유를 하고 있으면 크롬 프로세스와 putty프로세는 어떤 메모리에서 대기를 하게됨
> * 왜냐하면 CPU를 만일에 노트패드가 끝나면 크롬이 잡으면 노트패드는 실행될 수가 없음
> * CPU는 한순간에 하나의 프로세스밖에 실행을 못함/
> * 그리고 이렇게 각각 프로그램들이 프로세스화돼서 메모리에 올라오므로 메모리가 충돌할 일이 없음 -> 서로 독립적인 공간에서 작업을 하게 됨

### 프로세스 관리
* 프로세스의 생성에서 종료까지, 관리는 모두 커널에 의해 이루어짐
  * 커널 영역에 프로세스 테이블을 만들고, 프로세스들 목록 관리
* 관리 내용
  * 프로세스 생성, 실행, 일시 중단 및 재개, 정보 관리, 프로세스 통신, 프로세스 동기화, 프로세스 중단, 프로세스 컨텍스트 스위칭
 
![image](https://github.com/user-attachments/assets/cb2894b6-4f73-40c6-a458-6d81b3c8d29f)

![image](https://github.com/user-attachments/assets/6c26f108-e3b2-4cc6-ae6d-5086845915a2)

### 프로그램의 다중 인스턴스
#### 한 프로그램을 여러 번 실행시키면 어떻게 될까?
* 프로그램 실행 시 마다 독립된 프로세스 생성-> 프로세스들을 프로그램의 **다중 인스턴스**라고 부름
  * 각 프로세스에게 독립된 메모리 공간 할당
  * 각 프로세스를 별개의 프로세스로 취급
 
![image](https://github.com/user-attachments/assets/c5c3d427-60fa-4f3a-a256-6b3f5ec979bc)

> * Windows에서 사용자가 메모장 프로그램을 3번 실행 시켰을 때, 노트패드 프로세스가 3개 생성된 모양
> * 이들은 서로 다른 프로세스 번호를 부여받고, 서로 다른 메모리 공간에 적재되는 등 커널에 의해 완전히 별개의 프로세스들로 다루어짐

### CPU주소 공간
#### CPU 주소 공간(CPU address space)
* CPU가 주소선을 통해 액세스할 수 있는 전체 메모리 공간
* 공간 크기
  * CPU 주소선의 수에 의해 결정
* 32비트 CPU -> 32개의 주소선 -> $2^32$개의 주소 -> $2^32$바이트 -> 4GB공간
  * 1번지의 저장 공간 크기는 1바이트
  * 주소 공간은 0번지부터 시작 \~
 
* CPU주소 공간보다 큰 메모리? 있어도 액세스 불가능
* CPU주소 공간보다 작은 양의 메모리? 가능
  * 예: 32비트 CPU를 가진 컴퓨터(4GB까지 메모리 액세스 가능)에 2GB의 메모리가 설치되어 있을 때 2GB를 넘어서 액세스하면 없는 메모리를 액세스하므로 심각한 오류 발생
 
### 프로세스 구성 - 4개의 메모리 영역

![image](https://github.com/user-attachments/assets/ea727629-55be-47a7-a508-9a0368e31033)
![image](https://github.com/user-attachments/assets/ecd9cbc8-4d02-4c6a-8dcc-96bc6a084410)

1. 코드 영역
* 실행될 프로그램 코드가 적재되는 영역
  * 사용자가 작성한 **모든 함수의 코드**
  * 사용자가 호출한 라이브러리 함수들의 코드
 
2. 데이터 영역
* 프로그램에서 고정적으로 만든 변수 공간
  * 전역 변수 공간, 정적 데이터 공간
  * 사용자 프로그램과 라이브러리 포함
* 프로세스 적재 시 **할당**, **종료** 시 소멸

3. 힙 영역
* 프로세스의 실행 도중 동적으로 사용할 수 있도록 할당된 공간
  * malloc() 등으로 할당받는 공간은 힙 영역에서 할당
  * 힙 영역에서 아래 번지로 내려가면서 할당
 
4. 스택 영역
* 함수가 실행될 때 사용될 데이터를 위해 할당된 공간
  * 매개변수들, **지역변수들**, 함수 종료 후 돌아갈 주소 등
  * 함수는 호출될 때, 스택 영역에서 위쪽으로 공간 할당
  * 함수가 return하면 할당된 공간 반환
* 함수 호출 외에 프로세스에서 필요 시 사용 가능

### 프로세스 주소 공간
#### 프로세스 주소 공간
* 프로세스가 실행 중에 접근할 수 있도록 허용된 주소의 최대 범위
* 프로세스 주소 공간은 논리 공간(가상 공간)
  * 0번지에서 시작하여 연속적인 주소
 
#### 프로세스 주소 공간의 크기
* CPU가 액세스할 수 있는 전체 크기
  * 32비트 CPU의 경우 4GB(윈도우, 리눅스 모두 동일)
  * 프로세스 주소 공간 크기는 프로세스의 현재 크기와 다름
 
* 프로세스 주소 공간의 크기
  * 프로세스가 액세스할 수 있는 최대 크기(32비트 CPU의 경우 4GB)
 
* 프로세스의 크기
  * 적재된 코드+전역변수+힙 영역에서 현재 할당받은 동적 메모리 공간+스택 영역에 현재 저장된 데이터 크기
 
![image](https://github.com/user-attachments/assets/7e50247e-a3f9-4007-8eb8-8ae96f4294b5)
