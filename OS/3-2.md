### 프로세스 제어 블록(PCB)에 저장되는 정보
1. 프로세스 번호(PID): 0과 양의 정수, 유일한 번호, 이 번호로 프로세스 구분
2. 부모 프로세스 번호(PPID, Parent Process ID): 부모 프로세스의 PID
3. 프로세스 상태 정보: 준비, 실행 중, 블록(입출력 완료대기) 등
4. CPU 컨텍스트 정보
* PC(Program Counter): 프로세스가 선택되면 실행을 시작할 프로세스 내 코드 주소
  * 사용자 모드에 있었던 경우, 사용자 공간의 코드 주소
  * 커널 모드에 있었던 경우, 커널 공간의 코드 주소
* SP(Stack Pointer)
* 기타 레지스터(SP레지스터, 데이터 레지스터 등)

5. 스케줄링 정보
* 우선 순위값, nice값, 스케줄 큐에 대한 포인터 등
> * 프로세스의 우선 순위는 프로세스가 생성될 때 주어지며 시스템 호출을 통해 변경 가능
> * 커널의 스케줄러는 우선순위가 높을수록, 사용한 CPU시간이 짧을수록, 프로세스를 높은 순위로 스케줄링

6. 프로세스 종료 코드(정수 0\~255)
* 프로세스가 종료할 때 남기는 정수 값, exit() 시스템 호출의 매개변수값, main()함수의 return 값. 부모 프로세스에게 전달
> * 종료되었지만, 부모가 종료코드를 읽어가지 않은 상태의 프로세스를 **좀비 프로세스**라고 부름
> * 좀비 프로세스는 PCB와 프로세스 테이블 항목이 그대로 남아 있기 때문에, 프로세스 목록을 출력하면 좀비 상태로 출력

7. 프로세스의 오픈 파일 테이블: 열어놓은 파일 디스크립터들이 저장되는 배열
8. 메모리 관리 정보
* 페이지 테이블의 물리 메모리 주소 등

9. 프로세스 사이의 통신 정보들
10. 회계 정보
* CPU의 사용 시간, 제한 시간, 프로세스의 총 견과 시간 등, 사용료 계산이나 성능 통계에 사용

11. 프로세스 소유자 정보
* 프로세스를 생성한 사용자의 로그인 이름이나 사용자 ID 등

* 운영체제마다 프로세스 제어 블록에 저장되는 요소와 프로세스 상태 등이 다름

### 프로세스 생명 주기와 상태 변이
#### 프로세스 생명 주기
* 프로세스는 탄생에서 종료까지 여러 상태로 바뀌면서 실행
* 상태 정보는 PCB에 기록되고, 상태가 바뀔 때마다 갱신됨

![image](https://github.com/user-attachments/assets/06e9c910-10d0-4a03-8a87-e596f5cad9a7)

#### New(생성 상태)
* 프로세스가 생성된 상태. 메모리 할당 및 필요한 자원이 적재된 상태, PCB에 New상태로 등록. 실행 준비를 마치면 Ready 상태로 바뀜

#### Ready(준비 상태)
* 프로세스가 스케줄링을 기다리는 '준비 상태'
* 프로세스는 준비 큐에서 대기
* 스케줄링되면 Running상태로 되고 CPU에 의해 실행됨
> * 현재 실행중인 프로세스가 종료되거나 중단되는 경우, 커널은 준비 큐에서 한 개의 프로세스를 선택한다. 이 과정을 프로세스 스케줄링 또는 **CPU 스케줄링**이라 한다.
> * 프로세스가 Ready상태로 되는 경우는, New 상태에서 준비 큐에 삽입될 때, Running상태에서 프로세스에게 할당된 time slice가 경과되거나 스스로 다른 프로세스에게 CPU 사용을 양보할 때, 혹은 입출력 장치나 저장 장치로부터 요청한 작업이 완료되었을 때다.
#### Running(실행 상태)
* 프로세스가 CPU에 의해 현재 실행되고 있는 상태
* CPU의 시간할당량(타임슬라이스)이 지나면 다시 Ready상태로 바뀌고 준비 큐에 삽입
* 프로세스가 입출력을 시행하면 커널은 프로세스를 Blocked상태로 만들고 대기 큐에 삽입
> * 커널은 CPU스케줄링을 통해 선택된 프로세스의 PCB에 상태를 Running으로 기록하고 CPU에게 프로세스를 실행하게 하낟.
> * 프로세스의 실행이 완료되면
>   * 커널은 Terminated/Zombie상태로 만든다.
>   * 커널은 프로세스를 Running상태에서 다른 상태로 바꿀 때, 스케줄링을 시행하고,
>   * Running상태였던 프로세스의 컨텍스트를 PCB에 저장하고,
>   * 스케줄링된 프로세스의 PCB에서 컨텍스트를 CPU에 복귀시킨다.
>   * (컨텍스트 스위칭)

#### Blocked/Wait(블록 상태)
* 프로세스가 자원을 요청하거나, 입출력을 요청하고(예: read() 시스템 호출)완료를 기다리는 상태
* 입출력이 완료되면 프로세스는 Ready상태로 바뀌고 준비 큐에 삽입
> * 프로세스가 Running상태에서, 파일 읽기나 네트워크 수신과 같은 입출력, 타이머 기다리기, 자원 요청 등의 시스템 호출을 일으켰을 경우,
> * 커널은 현재 프로세스를 Bolcked 또는 Wait상태로 만든다.
> * 그리고 스케줄링을 통해 Ready 상태의 프로세스를 하나 선택하고 현재 프로세스와 컨텍스트를 스위칭한다.

#### Terminated/Zombie상태
* 프로세스가 불완전 종료된 상태(좀비 상태)
  * 프로세스가 차지하고 있던 메모리와 할당받았던 자원들을 모두 커널에 의해 반환됨. 커널에 의해 열어 놓은 파일도 닫힘
  * 하지만, 프로세스 테이블의 항목과 PCB가 여전히 시스템에서 제거되지 않은 상태
  * 프로세스가 남긴 종료 코드(PCB에 있음)를 부모 프로세스가 읽어가지 않아 완전히 종료되지 않은 상태 - 좀비 상태라고 부름
 
#### Terminated/Out 상태
* 프로세스가 종료하면서 남긴 종료 코드(PCB에 있음)를 부모 프로세스가 읽어 가서 완전히 종료된 상태
* 프로세스 테이블의 항목과 PCB가 시스템에서 완전히 제거된 상태

### 프로세스 스케줄링과 컨텍스트 스위칭
#### 프로세스 스케줄링과 스레드 스케줄링
* 프로세스 스케줄링
  * 과거 운영체제에서 실행 단위는 프로세스였음
  * Ready상태의 프로세스 중에 실행 시킬 프로세스 선택
 
* 오늘날 운영체제는 스레드를 대상으로 스케줄링
  * 오늘날 프로세스 스케줄링은 없음
  * 오늘날 운영체제에서 실행 단위는 스레드
  * Ready상태의 스레드 중 실행 시킬 스레드 선택
 
 #### 그럼 프로세스는 뭐지?
 * 프로세스는 **스레드들에게 공유 자원을 제공하는 컨테이너 역할**로 바뀜

### 프로세스 정보 보기
#### 프로세스 테이블과 PCB에서 액세스
* 사례: 리눅스 쉘 명령으로 프로세스 정보 보기

![image](https://github.com/user-attachments/assets/f1214f33-3219-4b63-87c9-e37817381d20)
> * USER: 로그인 이름
> * UID: 프로세스를 소유한 사용자 id
> * PID: 프로세스 번호
> * PPID: 부모 프로세스 번호
> * PRI: 커널이 스케줄링 시 참고할 프로세스의 우선순위 값으로 클수록 낮은 우선순위
> * NI: nice값으로 다른 프로세스에게 양보할 의지를 정수로 표현. 값이 클수록 낮은 우선순위로 처리
> * STAT: 프로세스 상태

### C프로그램으로 프로세스와 부모 프로세스 번호 알아내기
```c
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>

int main(){
    pid_t pid, ppid;
    pid=getpid();
    ppdi=getppid();
    printf("프로세스 ID: %d, 부모 프로세스 ID: %d", pid, ppid);
    return 0
}
```
![image](https://github.com/user-attachments/assets/c70a4842-1603-48a5-8928-e0086e8dd590)


## 3. 프로세스 계층 구조
### 프로세스의 부모 - 자식 관계
#### 프로세스는 일반적으로 부모-자식 관계
  * 윈도우에서 프로세스는 모두 동등 - 계층 관계 아님
* #0 프로세스가 시스템 부팅 시 실행되는 최초의 프로세스, 조상 프로세스
* 부모 프로세스는 여러 개의 자식 프로세스를 가질 수 있음
* 모든 프로세스는 부모 프로세스를 가짐(#0프로세스 제외)

#### 자식 프로세스의 생성
* 모든 프로세스는 프로세스(부모)에 의해 생성
  * 프로세스 생성은 **시스템 호출**을 통해서만 가능
    * fork(), clone() 등의 커널 코드가 자식 프로세스 생성
    * 예외: PID 0, 1, 2 등의 몇몇 조상 프로세스는 시스템 호출이 아닌 수작업으로 생성
   
#### 리눅스 사례
* #0 프로세스 - swapper/idle 프로세스(hand-crafted)
* #1 프로세스 - init 프로세스(hand-crafted)
  * 부팅 후 생성되는 모든 사용자 프로세스의 조상
* #2 프로세스 - kthreadd 프로세스(hand-crafted)
  * 커널 모드에서 커널 코드로만 실행되는 모든 커널 프로세스(thread)의 조상
 
### 부모-자식의 계층 관계로 구성되는 리눅스의 프로세스들
![image](https://github.com/user-attachments/assets/f876d065-b792-4f06-95a6-a8a2df48535d)

* #1과 #2 프로세스는 #0 프로세스에 의해 생성되지 않고 부팅 과정에서 하드코딩으로 생성되지만, 오래된 유닉스 운영체제의 관례에 따라 #1, #2 프로세스의 부모를 #0 프로세스로 다룬다.

![image](https://github.com/user-attachments/assets/43ca686b-6c1f-4a5b-a50c-b6013354c4a9)

* #1과 #2 프로세스의 PPID가 0인것 을 볼 수 있으며,
* #4 \~ #10까지의 프로세스는 모두 커널 모드에서 커널 공간에서만 실행되는 프로세스들로서 그들의 부모가 #2 프로세스인 것을 볼 수 있다.
* 또한 #974 sshd프로세스와 # 1654 agetty 프로세스의 부모는 #1 init 프로세스이며,
* #23623 ps의 부모 프로세스를 따라가면 #1까지 올라가는 것을 혹인할 수 있다.
* 사용자 모드에서 실행되는 모든 프로세스들의 조상은 **#1 init프로세스**이다.

![image](https://github.com/user-attachments/assets/8947fc4a-0c52-43c5-8e48-dd6897532683)

![image](https://github.com/user-attachments/assets/ca64061f-cdf1-47e7-bd45-32b2750cc2c3)

![image](https://github.com/user-attachments/assets/cf3b0c68-66fd-4899-ab55-aa7dcea3bfbd)


### #0과 #1 프로세스: idle 프로세스와 init 프로세스
#### #0 프로세스
* 최고의 어른(조상) 프로세스
* Unix의 #0 프로세스
  * swapper라고 불림, 부팅을 담당하고 #1 프로세스 생성
* Linux의 #0 프로세스
  * idle 프로세스, 부팅 관여 없이 아무 일도 하지 않고 루프
  * 우선순위가 가장 낮은 프로세스, 다른 프로세스가 있으면 실행될 일 없음
  * 실행 중인 프로세스가 1개도 없는 상태에 빠지지 않기 위해 만든 프로세스
  * Unix 시절의 관례에 따라 0번 프로세스이므로 swapper이라고도 부름
 
* Windows의 #0 프로세스: system idle process(시스템 유휴 프로세스)
  * 아무 일도 하지 않고 루프를 도는 단순 프로세스
  * 그림의 사례: CPU 시간의 89% 소모. 사용자가 컴퓨터를 사용하고 있지 않은 시간동안 실행

### 프로세스를 다루는 시스템 호출
#### fork()
* 자식 프로세스를 생성하는 시스템 호출

#### exit()
* 현재 프로세스의 종료를 커널에 알리는 시스템 호출
* 현재 프로세스의 종료를 처리하는 커널 코드 실행

#### Wait()
* 부모가 자식 프로세스의 종료를 기다리고 확인하는 시스템 호출

### 부모 프로세스와 자식 프로세스의 실행 관계
![image](https://github.com/user-attachments/assets/929fc12f-5c6d-44d5-9dc0-5a62f135680c)

> * a
>   * 부모 프로세스는 fork() 시스템 호출을 이용하여 자식 프로세스를 생성한 후, 자신에게 주어진 작업을 수행하고 나서, 자식 프로세스의 종료를 확인하기 위해 wait()를 호출한다.
>   * wait()는 자식 프로세스가 종료할 때까지 리턴하지 않고 커널 대에서 대기한다.
>   * 자식 프로세스가 exit()을 호출하여 종료하면, 커널은 대기 중인 부모 프로세스를 깨운다.
>   * 부모 프로세스는 wait() 시스템 호출 내에서 자식 프로세스의 PCB에 남겨진 종료 코드(exit code)를 읽고 자식 프로세스를 완전히 제거한다.
>   * 그 후 부모 프로세스는 wait()에서 리턴하여 실행을 계속 한다.
>  
> * b
>   * 부모가 wait()를 호출하기 전, 자식이 exit()을 호출하여 먼저 종료한 경우
>   * exit() 시스템 호출은 프로세스가 할당받은 메모리를 반환하고, 
