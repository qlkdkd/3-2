# 4. 스레드와 멀티스레딩
## 1. 프로세스의 문제점
### 프로세스의 문제점
#### 다중 프로세스를 이용한 멀티태스킹
* 응용 프로그램에서 여러 프로세스를 생성하여 동시에 여러 작업 실행
* 운영체제는 스케줄링을 통해 여러 프로세스(작업)를 번갈아 실행

#### 프로세스를 실행 단위로 하는 멀티태스킹의 문제점
1. 프로세스 생성의 큰 오버헤드
* 프로세스를 위한 메모리 할당, 부모프로세스로부터 복사
* PCB 생성, 매핑 테이블(페이지 테이블) 생성 등

2. 프로세스 컨텍스트 스위칭의 큰 오버헤드
* CPU 레지스터들을 컨텍스트로 PCB에 저장, 새 프로세스 컨텍스트를 PCB에서 CPU로 옮기는 시간
* CPU가 참고할 매핑 테이블(페이지 테이블)의 교체 시간
* CPU 캐시에 새 프로세스의 코드와 데이터가 채워지는데 걸리는 시간 등

3. 프로세스 사이 통신의 어려움
* 프로세스가 다른 프로세스의 메모리에 접근 불가
* 프로세스 사이의 통신을 위한 제 3의 방법 필요
* 커널 메모리나 커널에 의해 마련된 메모리 공간을 이용하여 데이터 송수신
  * 신호, 소켓, 메시지 큐, 세마포, 공유 메모리, 메모리 맵 파일 등
* 이 방법들은 코딩이 어렵고, 실행속도 느리고, 운영체제 호환성 부족

### 프로세스 사이의 통신 기법들
![image](https://github.com/user-attachments/assets/8ee2b9a0-2328-4cb7-b36c-29377c7ab091)

## 2. 스레드 개념
### 스레드 출현 목적
#### 프로세스를 실행 단위로 하는 멀티태스킹의 문제점
* 커널에 많은 시간, 공간 부담-> 시스템 전체 속도 저하

#### 효율적인 새로운 실행 단위 필요: 스레드 출현
1. 프로세스보다 크기 작음
2. 프로세스보다 생성 및 소멸이 빠름
3. 컨텍스트 스위칭 빠름
4. 통신이 쉬운 실행단위 필요

### 스레드 개념
#### 스레드는 실행 단위이며 스케줄링 단위
* 스레드는 응용 프로그램 개발자에게는 작업을 만드는 단위
  * 하나의 응용 프로그램에 동시에 실행할 여러 작업(스레드) 작성 가능
  * 작업은 독립적으로 실행되는 함수로 작성
* 스레드는 운영체제에게 실행 단위이고, 스케줄링 단위
* 스레드는 코드, 데이터, 힙, 스택을 가진 실체
* 스레드마다 스레드 정보를 저장하는 구조체 TCB(Thread Control Block) 있음

#### 프로세스는 스레드들의 컨테이너
* 프로세스 개념이 스레드들의 컨테이너 역할로 수정됨
* 프로세스는 반드시 1개 이상의 스레드로 구성
  * 프로세스가 생성될 때 운영체제에 의해 자동으로 1개의 스레드 생성: 메인 스레드(main thread)라고 부름
* 프로세스는 회사, 스레드는 직원에 비유
  * 직원은 회사의 목적을 위해 일을 하는 단위
  * 스레드는 프로세스(응용 프로그램)의 목적을 위해 동시에 실행될 작업(코드) 단위
  * 직원이 3명이면 동시에 일을 하는 사람이 3명인 것처럼, 프로세스에게 3개의 스레드가 있으면 3개의 작업이 동시에 실행
 
![image](https://github.com/user-attachments/assets/fcb2e7d7-5262-42fb-8eeb-6a1da6eed1e2)

![image](https://github.com/user-attachments/assets/298770e4-0872-45eb-a5ac-37159a3414ae)
> * 위 그림은 멀티스레드 운영체제에서 프로세스와 스레드를 관리하는 모양이다.
> * 프로세스마다 PCB가 생성되고, 스레드마다 스레드 정보를 담는 TCB 구조체가 생성된다.
> * TCB는 스레드 엔터티라고도 부르며, 스케줄링 단위가 스레드이므로 TCB나 스레드를 스케줄링 엔터티라고도 부른다.

#### 프로세스는 스레드들의 공유 공간(환경) 제공
* 모든 스레드는 프로세스의 코드, 데이터, 힙을 공유하며, 프로세스의 스택 공간을 나누어 사용
* 공유되는 공간을 이용하면 스레드 사이의 통신 용이
* -> 프로세스가 독립적인 메모리 공간을 가지고 있어 프로세스 사이에 데이터를 주고 받았는데 있었던 심각한 어려움 해소

![image](https://github.com/user-attachments/assets/4d6b4a61-5c46-46f4-bdfa-e8f67368edde)

![image](https://github.com/user-attachments/assets/7619639c-d082-4449-9c8a-a6f6edc0d18f)

#### 스레드가 실행할 작업은 함수로 작성
* 응용프로그램 개발자는 스레드가 실행할 작업을 함수로 작성
  * 함수를 실행할 스레드 생성을 운영체제에게 요청할 떄 스레드 생성
  * 운영체제는 TCB 생성, 함수의 주소를 스레드 실행 시작 주소로 TCB에 등록
  * 스레드 생성은 곧 TCB 생성
 
* 운영체제는 TCB 리스트로 전체 스레드 관리
  * 스레드 스케줄: TCB 중에서 하나 선택, 스레드 단위로 스케줄
  * TCB에 기록된 스레드의 시작 주소를 CPU에 적재하면 실행 시작됨
 
#### 스레드의 생명과 프로세스의 생명
* 스레드로 만든 함수가 종료하면 스레드 종료
* 스레드가 종료하면 TCB등 스레드 관련 정보 모두 제거
* 프로세스에 속한 모든 스레드가 종료될 때, 프로세스 종료

### 스레드 만들기 맛보기 -pthread 라이브러리 이용
#### 개요
* 2개의 스레드로 구성된 멀티스레드 C응용프로그램 작성
  * 메인 스레드와 calcThread 작성
#### 구성 
* mian()함수
  * calcThread스레드를 생성하여 1에서 100까지 합을 구하게 시키고
  * calcThread스레드의 종료를 기다린 후, 합(sum 변수) 출력
 
* calcThread() 함수
  * 스레드 코드
  * 정수를 매개변수로 받아 1에서 param까지 합을 구하여 전역변수 sum에 저장
 
* 전역변수 sum
  * calcThread와 main스레드 모두 접근
 
```c
#include <pthread.h> // pthread 라이브러리를 사용하기 위해 필요한 헤더 파일 
#include <stdio.h>
#include <stdlib.h>

void* calcThread(void *param); // 스레드로 작동할 코드(함수) 
int sum = 0; // main 스레드와 calcThread가 공유하는 전역 변수  

int main() {
        pthread_t tid; //  스레드의 id를 저장할 정수형 변수 
        pthread_attr_t attr; // 스레드 정보를 담을 구조체 

        pthread_attr_init(&attr); // 디폴트 값으로 attr 초기화 
        pthread_create(&tid, &attr, calcThread, "100"); // calcThread 스레드 생성 
	// 스레드가 생성된 수 커널에 의해 언젠가 스케줄되어 실행 

        pthread_join(tid, NULL); // tid 번호의 스레드 종료를 기다림 
	printf("calcThread 스레드가 종료하였습니다.\n");
	printf("sum = %d\n", sum);
}

void* calcThread(void *param) { // param에 "100" 전달 
	printf("calcThread 스레드가 실행을 시작합니다.\n");
        int to =  atoi(param); // to = 100 
	int i;

        for(i=1; i<= to; i++) // 1에서 to까지 합계산 
		sum += i; // 전역 변수 sum에 저장 
}

```
![image](https://github.com/user-attachments/assets/0de9e56f-00b9-4cfc-ae95-77fdf4ca2da9)

![image](https://github.com/user-attachments/assets/61bbc80f-d52d-4b55-90aa-e639e08603cb)

> #### 1
> * 커널은 makeThread 응용프로그램을 실행시키기 위해 프로세스를 생성하고 PCB를 만든다.
> * 그리고 main스레드의 TCB를 생성하고, 실행을 시작할 코드의 주소 즉 main()함수의 시작주소와 스레드 번호 등 여러 정보를 기록한다.
> * 위 그림(1)은 makeThread 프로세스가 생성된 직후 모습이다.
> * 프로세스의 주소 공간에는 main()과 calcThread()함수의 코드가 적재되어 있고 sum변수의 공간도 할당되어 있다.
> * 커널은 현재 스케줄 가능한 TCB가 한 개 뿐이므로 main스레드의 TCB를 선택한다.
> * 그러면 CPU는 main()함수에서 실행을 시작한다.
>
> #### 2
> * main()함수에서 다음과 같이 pthread 라이브러리에 들어 있는 **pthread_create()**함수를 호출하면, calcThread()함수에서 실행을 시작하는 스레드, 즉 TCB가 생성된다.
>
> ```c
>pthread_create(&tid, &attr, calcThread, "100");
> ```
> * 여기서, pthread_create()의 매개변수 "100"은 calcThread(void *param)함수의 매개변수 param에 전달된다.
> * pthread_create()함수는 **생성한 스레드의 번호를 tid에 넣고**, **스레드에 관한 정보를 attr에 저장한 채 리턴한다**.
> * 이때부터 2개의 TCB가 존재하므로 2개의 스레드가 동시에 실행되는 상황이 된다.
> * 위 그림 (2)는 pthread_create()에 의해 2개의 스레드가 생긴 직후 모습이다.
> * 커널은 스케줄링을 통해 2개의 PCB중 하나를 선택하여 실행시킨다.
> * 이때 선택된 TCB에 기록된 주소가 CPU의 PC로 옮겨지고 CPU는 그 주소에서부터 실행을 시작한다.
> * main 스레드와 calcThread중 어떤 스레드가 먼저 실행될 지 아무도 모른다.
>
> #### 3
> * (3)에서는 main스레드가 실행되어 **pthread_join(tid,..)**을 호출하여 tid번호의 calcThread 스레드가 종료하기를 기다린다.
> * 한편, calcThread는 for문을 돌면서 1에서 100까지의 합을 계산한다.
> * 그림은 현재 1에서 50까지 구한 합을 sum에 저장한 상태이다.
>
> #### 4
> * (4)에서는 calcThread()함수가 최종 합을 구하여 sum변수에 5050을 저장하고 종료하면 calcThread스레드의 TCB가 제거되며 calcThread스레드는 사라졌다.
> * calcThread스레드가 종료한다고 calcThread()함수의 코드가 사라지는 것은 아니다.
> * 그것은 그냥 적재된 코드일 뿐이다.
> * TCB가 없어졌기 떄문에 더 이상 스레드로 인식되진 않는다.
> * 이제, main()스레드는 pthread_join()함수에서 리턴하여 sum에 저장된 값 5050을 화면에 출력한다.
> * main()함수가 종료하면  main()스레드의 TCB도 제거되고 main스레드가 사라지며, 프로세스도 종료되어 사라진다.

### 맛보기 프로그램을 통한 스레드에 대한 이해
* 프로세스가 생성되면 자동으로 main스레드 생성
  * main스레드는 main()함수 실행
* 스레드 코드는 함수로 만들어진다.
  * calcThread() 함수
* 스레드 생성
  * 스레드는 pthread_create()등 라이브러리 함수나 시스템 호출을 통해 생성
* 스레드마다 TCB 1개 생성
  * TCB에는 스레드의 시작 주소 저장. 이 주소에서 실행 시작
    * 이 주소를 CPU로 옮기는 컨텍스트 스위칭이 일어나면, CPU가 스레드 코드 실행
  * 컨텍스트 스위칭되어 스레드가 중단되면 TCB에 현재 컨텍스트 정보 저장(실행을 재개할 주소 젖아)
  * TCB의 존재를 스레드의 존재로 인식하면 됨
* 스레드는 스케줄링되고 실행되는 실행 단위
* 프로세스는 스레드들의 컨테이너
  * 프로세스는 더이상 실행 단위 아님
  * 맛보기 프로세스 내에 main스레드와 calcThread 있음
  * 두 스레드가 종료되어야 프로세스 종료
* 프로세스는 스레드들에게 공유 공간 제공
  * 프로세스의 코드와 전역 변수는 모든 스레드에 의해 공유
  * 사례에서 main 스레드와 clacThread 스레드는 sum 변수 공유
 
### 멀티스레드 응용프로그램 사례
![image](https://github.com/user-attachments/assets/58c6a97c-354d-4e8b-9b4b-7ca7bc3cd4a0)

#### 미디어 플레이어 응용프로그램
* 최소 4개의 스레드
  * 네트워크나 파일로부터 인코딩된 미디어 데이터를 반복적으로 읽어들이는 스레드
  * 미디어 데이터를 디코딩하여 비디오와 오디오로 분리하는 스레드
  * 디코딩된 오디오 데이터를 스피커에 출력하는 스레드
  * 디코딩된 비디오 데이터를 디스플레이에 출력하는 스레드 등
 
* 각 스레드는 정해진 작업을 독립적으로 수행하고, 다른 스레드에게 데이터를 전달하면서 유기적으로 실행됨
* 미디어 플레이어 스레드를 하나로 만드는 경우, 네트워크로부터 데이터가 도착하기를 기다리는 시간이 길어지게 되면 오디오나 비디오의 출력이 멈추는 현상이 발생할 수 있음

#### 테트리스 게임 응용프로그램
* 음악을 연주하는 스레드
* 키를 입력받아 블록의 방향과 모양을 바꾸는 스레드
* 타이머에 의해 블록의 위치를 아래로 내리고 라인을 체크하는 스레드 등
* 키 입력을 처리하는 스레드와 블록의 위치를 아래로 조정하는 스레드는 블록 데이터를 공유하면서 유기적으로 실행된다.

### 멀티스레딩 분석
![image](https://github.com/user-attachments/assets/d9c9b498-b185-477a-a7ec-44db537916e9)

* 테트리스가 3개의 스레드로 구성된다는 것은 3개의 TCB가 존재한다는 것과 같은 말
* 3개의 TCB에는 테트리스 프로그램에 작성된 3개의 함수 주소가 각각 저장되어 있음
* 이 주소는 커널에게는 스레드를 실행시킬 시작 주소이다.

* TCB는 커널에 의해 생성되고 관리됨(시스템에 따라 스레드 라이브러리에 의해 관리되기도 함)
* 운영체제 커널이 스케줄링을 통해 한 개의 TCB를 선택하고 CPU에게 TCB에 저장된 주소에서 스레드 코드를 실행하도록 함
* 이런 식으로 응용 프로그램에 작성된 함수가 독립적으로 실행되는 스레드가 되는 것

> 다시 말하면, 함수는 다른 함수에 의해 호출되어 실행되지만, 스레드 함수의 코드는 **CPU가 바로 실행하도록 커널에 의해 직접 제어된다.**

### TIP. 멀티스레딩과 concurrency, parallelism
#### concurrency(동시성)
* 1개의 CPU에서 2개 이상의 스레드가 동시에 실행 중인 상태
  * 스레드가 입출력으로 실행이 중단될 떄 다른 스레드 실행
  * 타임 슬라이스 단위로 CPU를 사용하도록 번갈아 스레드 실행
* concurrency 사례: 3개의 스레드가 1개 CPU에 의해 동시 실행

![image](https://github.com/user-attachments/assets/de00fbdd-5ad5-4f58-85bd-e2452a332499)

#### parallelism(병렬성)
* 2개 이상의 스레드가 다른 CPU에서 같은 시간에 동시 실행
* parallelism 사례: 3개의 스레드가 3개의 CPU에 의해 동시 실행

![image](https://github.com/user-attachments/assets/ea3c24e8-ec2c-47dc-b377-73078a9076d9)
