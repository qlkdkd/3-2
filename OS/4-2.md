## 3. 스레드 주소 공간과 컨텍스트

### 스레드 주소 공간
> 스레드의 주소 공간(thread adress space)은 스레드가 실행 중에 사용하는 메모리 공간으로 스레드의 코드, 데이터, 힙, 스택 영역이며, 이들은 모두 프로세스의 주소 공간에 형성된다.

#### 스레드 주소 공간
* 스레드가 실행 중에 사용하는 메모리 공간
  * 스레드의 코드, 데이터, 힙, 스택 영역
* 프로세스의 주소 공간 내에 형성

#### 스레드 주소 공간은 프로세스 주소 공간 내에서 사적 공간과 공유 공간으로 구분
* 스레드 사적 공간: 스레드 스택, 스레드 로컬 스토리지(TLS, Thread Local Storage)
* 스레드 사이의 공유 공간: 프로세스의 코드(스레드 코드 포함), 프로세스의 데이터 공간, 프로세스의 힙 영역

![image](https://github.com/user-attachments/assets/8036e0b7-0633-400a-a267-592bd53809e4)

### 스레드 주소 공간에 대한 설명
#### 스레드 코드 영역
* 스레드가 실행할 작업의 함수, 프로세스의 코드 영역에 있음
* 스레드는 프로세스의 코드 영역에 있는 다른 모든 함수 호출 가능

#### 스레드 데이터 영역
* 스레드가 사용할 수 있는 데이터 공간
* 2개의 공간
  * 프로세스에 선언된 모든 전역 변수들 - 프로세스의 데이터 영역
    * 모든 스레드에 의해 공유되는 공간
    * 스레드들 사이의 통신 공간으로 유용하게 사용
  * 개별 스레드의 전용 변수 공간(스레드 로컬 스토리지)
    * 각 스레드마다 독립된 전용 변수 공간
    * static __thread와 같은 특별한 키워드로 선언
    * 운영체제에 따라 프로세스의 힙이나 스택에 할당됨
   
#### 스레드 힙
* 모든 스레드가 동적 할당받은 공간, 프로세스 힙 공간을 공유하여 사용
* 스레드에서 malloc()를 호출하면 프로세스의 힙 공간에서 메모리 할당

#### 스레드 스택
* 스레드가 생성될 때
  * 프로세스에게 할당된 스택에서 사용자 스택 할당
  * 커널 공간에서 스레드마다 커널 스택 할당
* 스레드가 시스템 호출로 커널에 진입할 때, 커널 스택 활용
* 스레드 종료 시, 스레드가 할당 받은 사용자 스택과 커널 스택 반환

#### 스레드 로컬 스토리지(TLS, Thread Local Storage)
* **스레드마다** 안전하게 다루고자 하는 데이터를 저장하기 위한 **별도의 영역**
  * 프로세스의 뎅터 영역은 모든 스레드의 공용 공간이므로
* 스레드가 자신만 사용할 변수들을 선언할 수 있는 영역
* 생성되는 영역: 운영체제마다 다름. 대체로 힙이나 **스택**에 할당
* 프로그램에서 할당받는 방법
  * 프로그래밍 언어마다 다름
 
#### C언어에서 스레드 로컬 스토리지 할당 사례
* 스레드 로컬 스토리지가 선언되면, 스레드가 생성될 때마다 모든 스레드에 동일한 크기의 공간 할당
```c
static __thread int sum=5;//스레드 로컬 스토리지에 할당될 변수 sum 선언
```
  * 스레드가 생길 떄마다, 각 스레드에 sum변수 크기의 스레드 로컬 스토리지가 할당되고 초기값이 5로 설정

* 스레드가 종료하면 스레드의 로컬 스토리지 사라짐

### 스레드 상태
#### 스레드 일생
* 스레드는 생성, 실행, 중단, 실행, 소멸의 여러 상태를 거치면서 실행
* 스레드 상태는 TCB에 저장
* 스레드 상태
  * 준비 상태(Ready): 스레드가 스케줄 되기를 기다리는 상태
  * 실행 상태(Running): 스레드가 CPU에 의해 실행 중인 상태
  * 대기 상태(Blocked): 스레드가 입출력을 요청하거나 sleep()같은 시스템 호출로 인해 중단된 상태
  * 종료 상태(terminated): 스레드가 종료한 상태
 
![image](https://github.com/user-attachments/assets/3d959b4e-6028-444b-a6e6-82df6a36cbb8)

![image](https://github.com/user-attachments/assets/b1d75e2a-892b-4e42-9929-64e3ad4d30fc)

### 스레드 운용(operation)
#### 응용프로그램이 스레드에 대해 할 수 있는 운용의 종류
1. 스레드 생성
* 프로세스가 생성되면 운영체제에 의해 자동으로 main 스레드 생성
* 스레드는 시스템 호출이나 라이브러리 함수를 호출하여 새 스레드 생성 가능
> #### 스레드 생성 과정
> * 먼저 TCB 구조체를 만든 후 스레드에게 ID 부여
> * 스레드가 실행을 시작할 코드(함수)의 주소를 TCB의 PC에 기록하고, 스레드 사용자 스택을 할당하고 그 주소를 TCB의 SP에 저장한 후, 스레드 상태를 Ready로 하고 스레드를 준비 리스트에 넣는다.
> * TCB를 프로세스의 PCB와 다른 TCB에 연결하면 끝난다.

2. 스레드 종료
* 프로세스 종료와 스레드 종료의 구분 필요
* 프로세스 종료
  * 프로세스에 속한 아무 스레드가 exit() 시스템 호출을 부르면 프로세스 종료(모든 스레드 종료)
  * 메인 스레드의 종료(C 프로그램에서 main()함수 종료) - 모든 스레드가 함께 종료
  * 모든 스레드가 종료하면 프로세스 종료
 
* 스레드 종료
  * pthread_exit()와 같이 스레드만 종료하는 함수 호출 시 해당 스레드만 종료
  * main()함수에서 pthread_exit()을 부르면 main스레드만 종료
 
3. 스레드 조인
* 스레드가 다른 스레드가 종료할 때까지 대기
  * 주로 부모 스레드가 자식 스레드의 종료 대기
 
![image](https://github.com/user-attachments/assets/5d0b301d-7abe-409c-b111-1f871688cc04)
> * 스레드 T1은 스레드 T2를 생성하여 복잡하고 긴 계산 작업을 시켰다.
> * T1은 자신의 작업을 끝내고 pthread_join()을 호출하여 T2가 계산을 마칠 떄까지 기다리고, T2가 종료하면 T1의 계산 결과를 이용하여 다음 작업을 수행한다.
> * 스레드 번호(tid)만 알면 아무 스레드나 다른 스레드를 조인할 수 있지만, 스레드 조인은 그림 4-14와 같이 부모 스레드가 자식 스레드를 생성하여 작업을 시키고 자식 스레드가 작업을 완료하기를 기다릴 때 주로 사용된다.

4. 스레드 양보
* 스레드가 자발적으로 yield()와 같은 함수 호출을 통해 스스로 실행을 중단하고 다른 스레드를 스케줄하도록 요청
> * 양보한 스레드는 Ready상태로 준비 큐에 들어가고, 준비 큐에 있는 스레드 중 하나가 스케줄링되어 실행된다.
> * 준비 큐에 아무 스레드로 없으면 양보한 스레드가 다시 실행된다.

![image](https://github.com/user-attachments/assets/2538be50-354e-45b0-ad93-f3455c39d09c)

![image](https://github.com/user-attachments/assets/0a4285fb-badf-4bb7-8d80-7ac7d687acb3)

### 스레드 제어 블록
#### 스레드 제어 블록(TCB; Thread Control Block)
* 스레드를 실행 단위로 다루기 위해 스레드에 관한 정보를 담은 구조체
  * 스레드 엔터티, 스케줄링 엔터티라고도 불림
* 커널 영역에 만들어지고, 커널에 의해 관리
  * 스레드가 생성될 때 커널에 의해 만들어지고, 스레드가 소멸되면 사라짐
 
![image](https://github.com/user-attachments/assets/99df2b41-d22a-42dc-860e-5d23f080ae4c)

### 스레드와 TCB, 그리고 PCB와의 관계
* 프로세스: 스레드들이 생기고 활동하는 자원의 컨테이너
* TCB들은 링크드 리스트로 연결

![image](https://github.com/user-attachments/assets/96959cba-c6e1-4ab8-bab5-e594487e4c68)

### 준비 리스트와 블록 리스트
![image](https://github.com/user-attachments/assets/d3a7a647-2f56-42fc-8c40-1cb5b83bdbdd)

#### 준비 리스트
* 준비 상태에 있는 스레드들의 TCB를 연결하는 링크드 리스트
* 스레드 스케줄링은 준비 리스트의 TCB들 중 하나 선택

#### 블록 리스트
* 블록 상태에 있는 스레드들의 TCB를 연결하는 링크드 리스트

> * 커널에 스케줄러 코드는 준비 리스트에 있는 TCB중 하나를 선택한다.
> * 실행 중인 스레드가 스스로 양보하거나 할당된 CPU 타임슬라이스를 다 소모한 경우 스레드의 TCB는 준비 리스트에 삽입된다.
> * 스레드가 입출력을 시행하여 블록 상태가 되면 블록 리스트에 삽입된다.
> * 이런 식으로 스레드는 상태에 따라 다른 리스트들로 이동한다.
> * 블록 리스트는 대기하는 자원이나 I/O 장치별로 따라 만들어지기도 한다.

### 스레드 컨텍스트 스위칭
#### 스레드 컨텍스트 스위칭(스레드 스위칭)
* 스레드 스케줄링 후,
* 현재 실행중인 스레드를 중단시키고, 선택된 스레드에게 CPU 할당
  * 현재 CPU 컨텍스트를 TCB에 저장하고,
  * 선택된 스레드의 TCB에서 컨텍스트를 CPU에 적재, CPU는 선택된 스레드 실행
 
![image](https://github.com/user-attachments/assets/2498ea0c-2801-48eb-bce8-b31053bed76c)

### 스레드 스위칭이 발생하는 4가지 경우
#### 스레드 스위칭이 발생하는 4가지 경우
1. 스레드가 자발적으로 다른 스레등게 양보
  * yield() 등의 시스템 호출(혹은 라이브러리 호출)을 통해
2. 스레드가 시스템 호출을 실행하여 블록되는 경우
  * read(), sleep(), wait()등 I/O가 발생하거나 대기할 수 밖에 없는 경우
3. 스레드의 타임 슬라이스(시간 할당량)를 소진한 경우
  * 타이머 인터럽트에 의해 체크되어 진행
4. I/O장치로부터 인터럽트가 발생한 경우
  * 현재 실행중인 스레드보다 높은 순위의 스레드가 I/O 작업을 끝낸 경우 등

* 상황에 따라 운영체제에 따라, 이들 4가지 경우 외에도 스레드 스위칭이 일어날 수도 있고 아닐 수도 있음

### 스레드 스위칭이 이루어지는 위치
#### 스레드 스위칭이 이루어지는 위치는 2가지
1. 스레드가 시스템 호출을 하여, 커널이 **시스템 호출을 처리하는 과정**에서
2. 인터럽트가 발생하여 **인터럽트 서비스 루틴이 실행**되는 도중 커널 코드에서

### 스레드 스위칭 과정(스레드 A에서 스레드 B로)
![image](https://github.com/user-attachments/assets/6d33a2d3-e090-4f16-9b62-671d4ba178cd)

### 컨텍스트 스위칭 오버헤드
#### 컨텍스트 스위칭에는 어떤 부담(오버헤드)이 있는가?
* 컨텍스트 스위칭은 모두 CPU작업-> CPU시간 소모
* 컨텍스트 스위칭의 시간이 길거나, 잦은 경우 컴퓨터 처리율 저하

#### 구체적인 컨텍스트 스위칭 오버헤드
* **동일한 프로세스 내 다른 스레드로** 스위칭되는 경우
  1. 컨텍스트 저장 및 복괴
    * 현재 CPU의 컨텍스트(PC, PSP, 레지스터)TCB에 저장
    * TCB로부터 실행할 스레드의 스레드 컨텍스트를 CPU에 복귀
  2. TCB 리스트 조작
  3. 캐시 플러시와 채우기 시간

* **다른 프로세스의 스레드로** 스위칭하는 경우
  * 다른 프로세스로 교체되면, CPU가 실행하는 주소 공간이 바뀌는 큰 변화로 인한 추가적인 오버헤드 발생
  1. 추가적인 메모리 오버헤드
    * 시스템 내에 현재 실행 중인 프로세스의 매핑 테이블로 교체
  2. 추가적인 캐시 오버헤드
    * 프로세스가 바뀌기 때문에, 현재 CPU캐시에 담긴 코드와 데이터를 무효화시킴
    * 새 프로세스의 스레드가 실행을 시작하면 CPU 캐시 미스 발생, 캐시가 채워지는데 상당한 시간 소요
 
## 4. 커널 레벨 스레드와 사용자 레벨 스레드
### 커널 레벨 스레드와 사용자 레벨 스레드
#### 스레드 스케줄링 주체에 따라 2 종류의 스레드로 구분
* 커널 레벨 스레드: **커널에 의해 스케줄링**되는 스레드
* 사용자 레벨 스레드: **스레드 라이브러리에 의해 스케줄링**되는 스레드

#### 커널 레벨 스레드
* *스레드에 대한 정보(TCB)는 커널 공간에 생성되며 커널에 의해 소유됨*
* 응용프로그램이 시스템 호출을 통해 커널 레벨 스레드 생성
* 커널이 만들고, 커널에 의해 스케줄
* *스레드 주소 공간(스레드 코드와 데이터): 사용자 공간에 존재*
* main()스레드는 커널 스레드
  * 응용 프로그램을 적재하고 프로세스를 생성할 때 커널은 자동으로 main()스레드 생성
  * main스레드의 TCB는 커널에 생성
 
#### 사용자 레벨 스레드
* 응용 프로그램이 라이브러리 함수를 호출하여 사용자 레벨 스레드 생성
* *스레드 라이브러리가 스레드 정보(U-TCB)를 사용자 공간에 생성하고 소유*
  * 스레드 라이브러리는 사용자 공간에 존재
  * 커널은 사용자 레벨 스레드의 존재에 대해 알지 못함
* 스레드 라이브러리에 의해 스케줄
* *스레드 주소 공간(스레드 코드와 데이터): 사용자 공간에 존재*

프로세스 기반의 운영체제에서 스레드 라이브러리에 의해 관리되는 사용자 레벨 스레드

![image](https://github.com/user-attachments/assets/f609c9b6-ea58-4193-98a8-d5884319b52a)

> * 그림 4-20은 프로세스 기반의 운영체제에서 스레드 라이브러리에 의해 사용자 레벨 스레드가 생성되고 실행되는 모습을 보여준다.
> * 그림에서 3개의 PCB가 만들어져 있고, 커널은 3개의 프로세스가 실행되고 있다고만 알고 있다.
> * 그리고 현재 PCB3이 선택되어 프로세스3이 실행되고 있는 상황이다.
> * 프로세스 3은 스레드 라이브러리를 이용하여 3개의 사용자 레벨 스레드를 생성하였으며, 스레드 라이브러리는 3개의 스레드에 관한 정보(U-TCB)를 생성 관리하고, 자체에 내장한 스케줄러 코드를 이용하여 이들 중 하나를 선택하여 스레드 코드를 실행시킨다.
> * 현재는 프로세스3의 스레드2가 실행 중이다.
> * 커널은 사용자 스레드의 존재에 대해 전혀 알지 못하며, 프로세스3의 개발자는 3개의 스레드를 만들었다고 생각한다.

### 순수 커널 레벨 스레드
#### 순수 커널 레벨 스레드
* 부팅 때부터 커널의 기능을 돕기 위해 만들어진 스레드
* 커널 코드를 실행하는 커널 스레드
* *스레드의 주소 공간은 모두 커널 공간에 형성*
* 커널 모드에서 작동, 사용자 모드에서 실행되는 일은 없음

![image](https://github.com/user-attachments/assets/2d3319e6-e5fc-4d40-821b-7782a4879b02)

### 사례 설명
#### 사례 개요: 프로세스 2개, 커널 레벨 스레드 4개, 사용자 레벨 스레드 3개
#### 2개의 순수 커널 레벨 스레드
* 프로세스당 하나의 커널 레벨 스레드(main 스레드) 자동 생성
* TCB3
  * 커널은 단일 스레드 프로세스1을 적재할 때 자동으로 main 스레드 TCB3 생성
  * 커널이 프로세스1을 실행시키기 위함
* TCB4
  * 커널은 멀티스레드 프로세스2를 적재할 때 자동으로 main스레드 TCB4 생성
  * 커널이 프로세스2를 실행시키기 위함
* TCB3과 TCB4의 스레드 주소 공간은 모두 사용자 공간에 있음

#### 3개의 사용자 레벨 스레드
* 프로세스2의 main()함수가 라이브러리 함수를 호출하여 자신을 사용자 레벨 스레드로 등록
  * U-TCB1 생성
* 프로세스2의 main()함수가 라이브러리 함수를 호출하여 2개의 사용자 레벨 스레드 추가 생성
  * U-TCB2, U-TCB3 생성
 
#### 스레드 스케줄링
* 커널에 의한 스케줄(TCB1\~TCB4중에서 선택)
  * 코어 1: TCB2 실행(TCB2가 가리키는 커널 스레드 코드2 실행)
  * 코어 2: TCB4 실행(TCB4가 가리키는 프로세스 내의 코드 실행)
    * 처음에는 프로세스2의 main()함수에서 실행을 시작하지만 현재 어떤 함수의 코드를 실행하고 있는지 알 수 없음
    * 커널은 프로세스2 내에 하나의 스레드만 있다고 생각함
   
#### 프로세스2에서의 사용자 스레드 스케줄링
* 스레드 라이브러리가 3개의 사용자 스레드 스케줄
  * 예: main()함수가 스레드 라이브러리의 yield()함수를 호출하면, 이 함수는 스레드 라이브러리 내 scheduler를 호출하여, U-TCB2, U-TCB3중에서 하나를 선택한다.
  * 만일 U-TCB3이 선택되었다면, U-TCB1에 현재 실행 주소 등을 저장해 두고, U-TCB3에 저장된 실행 시작 주소(스레드 코드3)로 점프하여 실행 시작-> U-TCB3이 스케줄되었다.
 
![Uploading image.png…]()
