# 5. CPU 스케줄링
스케줄링이란 CPU가 여러 프로세스나 스레드를 효율적으로 나누어 처리하는 정책

## 1. CPU 스케줄링 개요
### 운영체제에서 일어나는 다양한 스케줄링
#### 스케줄링은 왜 필요할까?
  * 자원에 대한 경쟁이 있는 곳에서 경쟁자 중 하나 선택
  * 자원: CPU, 디스크, 프린트, 파일, 데이터베이스 등
* 컴퓨터 시스템 여러 곳에서 발생

#### 컴퓨터 시스템 내 다양한 스케줄링
* 작업(job) 스케줄링
  * 배치 시스템에서
  * 대기중인 배치 작업 중 메모리에 적재할 작업 결정
> 배치는 일괄처리를 의미. 미니 배치는 데이터를 일괄처리하여 GPU의 처리량을 효율적으로 만드는 것임

* CPU스케줄링
  * 프로세스/스레드 중에 하나를 선택하여 CPU할당
  * 오늘날 CPU스케줄링은 스레드 스케줄링
 
* 디스크 스케줄링
  * 디스크 장치 내에서
  * 디스크 입출력 요청 중 하나 선택
 
* 프린터 스케줄링
  * 프린팅 작업 중 하나 선택하여 프린팅 할당
 
### 다중 프로그래밍과 스케줄링
#### 다중 프로그래밍의 도입 목적 리뷰
* CPU유휴 시간 줄여 CPU활용률 향상 목적
  * 프로세스가 I/O를 요청하면 다른 프로세스에게 CPU할당
 
#### 다중 프로그래밍과 함께 2가지 스케줄링 도입
* 작업 스케줄링(job scheduling)
  * 디스크 장치로부터 메모리에 올릴 작업 선택(초기 다중 프로그래밍 시스템에서)
  * 처음에 혹은 프로세스가 종료할 때마다
 
* CPU 스케줄링
  * 메모리에 적재된 작업 중 CPU에 실행시킬 프로세스 선택
![image](https://github.com/user-attachments/assets/75246eb3-3c6a-46e0-8427-8faa89d95de4)

### CPU burst와 I/O burst
#### 프로그램의 실행 특성
* CPU 연산 작업과 I/O 작업(화면 출력, 키보드, 입력, 파일 입출력 등)이 순차적으로 섞여 있음
* CPU burst - I/O burst - CPU burst - I/O burst의 반복

#### CPU burst
* 프로그램 실행 중 CPU연산(계산 작업)이 연속적으로 실행되는 상황

#### I/O burst
* 프로그램 실행 중 I/O 장치의 입출력이 이루어지는 상황

![image](https://github.com/user-attachments/assets/14fedab9-d5f9-4ca6-a1f2-655cf408478f)

> * CPU burst시간이 IO burst시간보다 절대적으로 많을 때, CPU집중 프로세스라고 하고,
> * 그 반대의 경우 I/O 집중 프로세스라고 함

### CPU 스케줄링의 정의와 목표
#### CPU스케줄링
* 정의: 실행 준비 상태(Ready)의 스레드 중 하나를 선택하는 과정
* 기본 목표: CPU 활용률 향상-> 컴퓨터 시스템 처리율 향상
* 컴퓨터 시스템에 따라 CPU 스케줄링의 목표가 다를 수 있다.

### CPU 스케줄링의 기준(criteria)
#### 스케줄링 알고리즘의 다양한 목표와 평가 기준
* CPU 활용률(CPU utilization)
  * 전체 시간 중 CPU의 사용 시간 비율, 운영체제 입장
* 처리율(throughput)
  * 단위시간당 처리하는 스레드 개수, 운영체제 입장
* 공평성(fairness)
  * CPU를 스레드들에게 공평하게 배분, 사용자 입장
  * 시분할로 스케줄링
  * 무한정 대기하는 기아 스레드가 생기지 않도록 스케줄
* **응답시간**
  * 대화식 사용자의 경우,사용자에 대한 응답 시간, 사용자 입장
* **대기시간**
  * 스레드가 준비 큐에서 머무르는 시간, 운영체제와 사용자 입장
* **소요 시간**
  * 프로세스(스레드)가 컴퓨터 시스템에 도착한 후(혹은 생성된 후) 완료될 때까지 걸린 시간, 사용자 입장
  * 배치처리 시스템에서 주된 스케줄링의 기준표
* 시스템 정책 우선
  * 컴퓨터 시스템의 특별한 목적을 달성하기 위한 스케줄링, 운영체제 입장
  * 예) 실시간 시스템에서는 스레드가 완료 시한(deadline) 내에 이루어지도록 하는 정책
  * 예) 급여 시스템에서는 안전을 관리하는 스레드를 우선 실행하는 정책 등
* 자원 활용률
  * 자원이 놀지 않도록 자원 활용률을 극대화하는 것
 
### 타임 슬라이스
#### 대부분 운영체제에서
* 하나의 스레드가 너무 오래 CPU를 사용하도록 허용되지 않음

#### 타임 슬라이스와 스케줄링
* 타임 슬라이스
  * 스케줄된 스레드에게 한 번 할당하는 CPU 시간
    * 스레드가 CPU 사용을 보장받는 시간
  * 커널이 스케줄을 단행하는 주기 시간
    * 타이머 인터럽트의 도움을 받아 타임 슬라이스 단위로 CPU 스케줄링
    * 현재 실행중인 스레드 강제 중단(preemption), 준비 리스트에 삽입
  * 타입 퀀텀, 타임 슬롯이라고도 함
 
![image](https://github.com/user-attachments/assets/ec8a9342-74be-4716-8ee9-ccac7b1b50fd)

> * 타임슬라이스와 타임아웃 이해
>   * 1ms가 지났다는 것은 현재 기지국에서 받아온 시간 전체와 동일한 시간에서 떨어진다는 것을 의미함
>   * 타임아웃은 타이머가 사용하는 하드웨어적 타이머의 일종으로 현상의 기준이 되는 타임이 얼마나 지났는지 나타냄
>   * 클럭 제너레이터가 발생하면, 라이징 엣지에 인터럽트를 디텍트함
>   * 카운트 디지털 값인 N이 도착하면 1ms가 지났음을 알려줌
>  
> * 스레드와 스케줄링
>   * 시스템에서 n번 카운팅이 되면, 1ms가 지났음을 알려줌
>   * 기지국에서 스마트폰이 원하는 레지스트레이션을 받지 못하면, 시간을 계산하여 기지국에 도착하도록 함
>   * 통신이 성공하지 않으면, 기지국에 다시 도착하여 다시 기다리는 상태로 전환함
>   * 이때, 타임 슬라이스가 사용됨
>  
> * 타임슬라이스의 역할과 중요성
>   * 타임 슬라이스는 스케줄링 단위로, 각 스레드가 사용할 시간을 결정함
>   * 스마트폰의 타임 슬라이스는 1ms이며, 각각의 스레드는 10ms를 가짐
>   * 기지국이 제공하는 레지스트레이션에 따라 스레드가 올바른 타임 슬라이스를 할지 결정함
>   * 이를 통해 CPU스케줄링이 진행되며, 이때 모든 스레드는 동일한 타임 슬라이스를 가짐

## 2. CPU 스케줄링 기본
### CPU 스케줄링이 실행되는 4가지 상황
#### CPU 스케줄링은 언제 시행될까?
1. 스레드가 시스템 호출 끝에 I/O를 요청하여 블록될 때
  * 스레드를 블록 상태로 만들고 스케줄링
  * (CPU활용률 향상 목적)
2. 스레드가 자발적으로 CPU를 반환할 때
  * yield() 시스템 호출 등을 통해 스레드가 자발적으로 CPU 반환
  * 커널은 현재 스레드를 준비 리스트에 넣고, 새로운 스레드 선택
  * (CPU의 자발적 양보)
3. 스레드의 타임 슬라이스가 소진되어 타이머 인터럽트 발생(-> thread swithing)
  * (균등한 CPU 분배 목적)
4. 더 높은 순위의 스레드가 요청한 입출력 작업 완료, 인터럽트 발생
  * 현재 스레드를 강제 중단시켜 준비 리스트에 넣고
  * 높은 순위의 스레드를 깨워 스케줄링
  * (우선순위를 지키기 위한 목적)

###  CPU 스케줄링과 디스패치(dispatch)
#### CPU 스케줄링 코드의 위치와 실행 시점(-> 커널 내에 있음) 
  * 스케줄링 담당하는 커널 스레드나 프로세스가 있는가? 없다.
1. 스케줄링 코드는 어디에 위치? 커널 내 함수로
   * 스케줄링 코드는 커널 코드의 일부로서 호출되어야 실행되는 함수 형태
   * 독립적으로 실행되는 프로세스나 스레드 아님
2. 스케줄링 코드가 실행되는 시점
   * 시스템 호출이나 인터럽트 서비스 루틴이 끝나는 마지막 단계에서 실행
  
![image](https://github.com/user-attachments/assets/bd361d82-3f56-46d4-96a2-e7f9bbaab211)

### 선점 스케줄리오가 비선점 스케줄링
#### 실행준인 스레드의 강제 중단 여부에 따른 CPU 스케줄링
* 비선점 스케줄링(non-preemptive scheduling) 타입
  * 현재 실행중인 스레드를 **강제로 중단시키지 않는** 타입
    * 스레드가 CPU를 할당받아 실행을 시작하면, 완료되거나 CPU를 더 이상 사용할 수 없는 상황이 될 때까지 스레드를 강제 중단시키지 않고 스케줄링도 하지 않는 방식
  * 스케줄링 시점
    * CPU를 더 이상 사용할 수 없게 된 경우: I/O로 인한 블록 상태, sleep() 등
    * 자발적으로 CPU 양보할 때
    * 종료할 때
* 선점 스케줄링(preemptive scheduling) 타입
  * 현재 실행중인 스레드를 **강제 중단**시키고 다른 스레드 선택
  * 스케줄링 시점
    * 타임슬라이스가 소진되어 타이머 인터럽트가 발생될 때
    * 인터럽트나 시스템 호출 종료 시점에서, 더 높은 순위의 스레드가 준비 상태일 때
#### 오늘날
* 일부 실시간 임베디드 시스템 운영체제: 비선점 스케줄링
* 그 외 대부분 운영체제: 선점 스케줄링

![image](https://github.com/user-attachments/assets/228fc714-8e83-4105-86a9-aad8ae61f37b)
> (a)
> * 비선점 스케줄링
> * T1이 먼저 실행을 시작하면 종료할 때까지 스케줄링이 이루어지지 않으며, T1이 종료될 때 비로소 스케줄링이 이루여져 T2가 실행된다.
> * T2의 실행 중 I/O가 발생하면 T2를 중단시키고 스케줄링을 실행하여 T3을 선택한다.
> * T3이 실행 중 yield()를 호출하면 준비 상태인 T2를 스케줄링하고 실행시킨다.
> * T2가 끝날 때 다시 스케줄링이 이룬어지고 T3이 실행된다.
>
> (b)
> * 선점 스케줄링은 타임 슬라이스마다 실행 중인 스레드를 강제로 중단시켜 준비(ready)상태로 만들고 다른 스레드를 실행시킨다.
> * T1을 타임 슬라이스만큼 실행시킨 후, T2를 스케줄하여 실행시킨다.
> * 스케줄링 번호 5와 같이, T2가 실행 중 I/O를 요청하면 T2를 블록시키고 할당된 타임 슬라이스가 소진되기 전이지만 스케줄링을 실행한다.
> * 이런 식으로 선점 스케줄링이 일어나다가, T3이 yield() 시스템 호출을 실행하면 커널은 T3을 준비 상태로 만들고 스케줄링을 실행한다(스케줄링 번호 11)
> * 스레드가 종료하면, 스케줄링을 통해 다른 스레드를 실행시킨다.(스케줄링 번호 13)

### 기아와 에이징
#### 기아(starvation)
* 스레드가 스케줄링에서 선택되지 못한 채 오랫동안 준비 리스트에 있는 상황
* 사례
  * 우선순위를 기반으로 하는 시스템에서, 더 높은 순위의 스레드가 계속 시스템에 들어오는 경우
  * 짧은 스레드를 우선 실행시키는 시스템에서, 자신보다 짧은 스레드가 계속 도착하는 경우
* 스케줄링 알고리즘 설계 시 기아 발생을 면밀히 평가
  * 기아가 발생하지 않도록 설계하는 것이 바람직함
 
#### 에에징(aging)
* 기아의 해결책
* 스레드가 준비 리스트에 머무르는 시간에 비례하여 스케줄링 순위를 높이는 기법
  * 오래 기다릴 수는 있지만 언젠가는 가장 높은 순위에 도달하는 것 보장
