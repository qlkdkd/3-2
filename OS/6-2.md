## 3. 멀티스레드 동기화 기법
### 멀티스레드 동기화
#### 멀티스레드 동기화란?
* 상호배제 기반 위에
* 자원을 사용하려는 여러 스레드들이 자원을 원활히 공유하도록 하는 기법
* 동기화 프리미티브(synchronization primitives)로 부름

#### 대표적인 기법
* locks방식: 뮤텍스(mutex), 스핀락(spinlock)
  * 상호배제가 되도록 만들어진 락(lock) 활용
  * 락을 소유한 스레드만이 임계구역 진입
  * 락을 소유하지 않은 스레드는 락이 풀릴 때까지 대기
 
* wait-signal 방식: 세마포(semaphore)
  * n개의 자원을 사용하려는 m개 멀티스레드의 원활한 관리
  * 자원을 소유하지 못한 스레드는 대기(wait)
  * 자원을 다 사용한 스레드는 알림(signal)
 
![image](https://github.com/user-attachments/assets/96f86b47-d21b-473b-8575-5c4180ecd34f)

### 뮤텍스
![image](https://github.com/user-attachments/assets/cae9ec22-7047-4407-b995-7217f0ec5845)

#### 뮤텍스 기법
* 잠김/열림 중 한 상태를 가지는 락 변수 이용
* 한 스레드만 임계구역에 진입시킴
* 다른 스레드는 큐에 대기
* sleep-waiting lock 기법

#### 뮤텍스 기법의 구성요소
1. 락 변수
  * true/false 중 한 값
  * true: 락을 잠근다. 락을 소유한다.
  * false: 락을 연다. 락을 해제한다.
2. 대기 큐
  * 락이 열리기를 기다리는 스레드 큐
3. 연산
  * lock연선(임계구역의 entry코드)
    * 락이 열린 상태이면, 락을 잠그고 임계구역 진입
    * 락이 잠김 상태(lock=true)이면, 현재 스레드를 블록 상태로 만들고 대기 큐에 삽입
  * unlock연산(임계구역의 exit코드)
    * lock=false, 락을 열린 상태로 변경
    * 대기 큐에서 기다리는 스레드 하나 깨움
   
![image](https://github.com/user-attachments/assets/1de82993-7e2d-429c-8ff7-24f8a8504ad9)

1. T1스레드가 lock연산을 실행하여 락을 잠그고 임계구역을 실행한다.
2. T1이 임계구역을 실행하는 도중 T2가 실행되어 lock 연산을 실행한다. lock연산은 락이 잠겨 있어 T2를 중단시키고 대기 큐에 삽입한다.
3. T1이 임계구역의 실행을 마치고 unlock연산을 실행한다. unlock연산은 락을 열림 상태로 바꾼 후 대기 큐에서 잠든 스레드 하나를 깨워 준비 리스트에 넣는다. T1은 unlock연산 후 작업을 계속한다.
4. 깨어난 스레드 T2는 준비 리스트에 있다가 스케줄되면 중단된 lock연산에서 실행을 계속하여 락이 잠겨있는지 검사하고 락을 잠근 후 임계구역으로 들어간다.

### 뮤텍스의 특징
#### 뮤텍스를 이용한 동기화 특징
* 임계구역의 실행 시간이 짧은 경우, 비효율적
  * 락이 잠겨 있으면(컨텍스트 스위칭되어) 대기 큐에서 대기, 락이 풀리면 다시(컨텍스트 스위칭되어) 실행
  * 락이 잠겨잇는 시간보다 스레드가 잠자고 깨는 데 걸리는 시간이 상대적으로 크면 비효율적
 
#### 뮤텍스 동기화를 위한 POSIX 라이브러리
* 뮤텍스락 변수
  * pthread_mutex_t lock;
* 대기큐는 pthread 라이브러리 내부에 구현되어 있기 때문에 사용자에게 보이지 않음
* 뮤텍스 조작 함수들
  * pthread_mutex_init(): 뮤텍스락 변수 초기화
  * pthread_mutex_lock(): 뮤텍스락 잠그기
  * pthread_mutex_unlock(): 뮤텍스락 풀기
  * pthread_mutex_destroy(): 뮤텍스락 변수 사용 종료
 
![image](https://github.com/user-attachments/assets/dde0b057-e784-4d8c-a1fb-f13ce0b6b8f2)

### 탐구 6-2. pthread의 뮤텍스를 이용한 공유집계판의 스레드 동기화
```c
#include <stdio.h>
#include <pthread.h>

int sum = 0; // 두 스레드가 공유하는  변수
pthread_mutex_t lock;	// 뮤텍스락 변수 선언

void* worker(void* arg) { // 스레드 코드
	printf("%s 시작\t %d\n", (char*)arg, sum);
	for(int i=0; i<1000000; i++) {
		pthread_mutex_lock(&lock); // entry 코드. 뮤텍스락 잠그기
		sum = sum + 10;
		pthread_mutex_unlock(&lock); // exit 코드. 뮤텍스락 열기
	}
	printf("%s 끝\t %d\n", (char*)arg, sum);
}
int main() {
	char *name[] = {"황기태", "이찬수"};
	pthread_t tid[2];
	pthread_attr_t attr[2]; // 스레드 정보를 담을 구조체

	pthread_attr_init(&attr[0]); // 디폴트 속성으로 초기화
	pthread_attr_init(&attr[1]); // 디폴트 속성으로 초기화

	pthread_mutex_init(&lock, NULL); // 뮤텍스락 변수 lock 초기화

	pthread_create(&tid[0], &attr[0], worker, name[0]);  // 스레드 생성
	pthread_create(&tid[1], &attr[1], worker, name[1]); // 스레드 생성

	pthread_join(tid[0], NULL); // 스레드 종료 대기
	pthread_join(tid[1], NULL); // 스레드 종료 대기

	printf("최종 sum = %d\n", sum); // 두 스레드 종료 후 sum 출력

	pthread_mutex_destroy(&lock); // 뮤텍스락 lock 사용 끝

	return 0;
}
```
![image](https://github.com/user-attachments/assets/168dc43e-5ca7-4ee2-97e9-77e2dfd64616)

#### worker()함수를 다음과 같이 작성하면 어떻게 될까?
```c
#include <stdio.h>
#include <pthread.h>

int sum = 0; // 두 스레드가 공유하는  변수
pthread_mutex_t lock;	// 뮤텍스락 변수 선언

void* worker(void* arg) { // 스레드 코드
    printf("%s 시작 \t %d\n", (char*)arg, sum);
    pthread_mutex_lock(&lock);//lock
    for(int i=0; i<1000000; i++){
        sum+=10;
    }
    pthread_mutex_unlock(&lock);//unlock
    printf("%s 끝 \t %d\n", (char*)arg, sum);
}
int main() {
	char *name[] = {"황기태", "이찬수"};
	pthread_t tid[2];
	pthread_attr_t attr[2]; // 스레드 정보를 담을 구조체

	pthread_attr_init(&attr[0]); // 디폴트 속성으로 초기화
	pthread_attr_init(&attr[1]); // 디폴트 속성으로 초기화

	pthread_mutex_init(&lock, NULL); // 뮤텍스락 변수 lock 초기화

	pthread_create(&tid[0], &attr[0], worker, name[0]);  // 스레드 생성
	pthread_create(&tid[1], &attr[1], worker, name[1]); // 스레드 생성

	pthread_join(tid[0], NULL); // 스레드 종료 대기
	pthread_join(tid[1], NULL); // 스레드 종료 대기

	printf("최종 sum = %d\n", sum); // 두 스레드 종료 후 sum 출력

	pthread_mutex_destroy(&lock); // 뮤텍스락 lock 사용 끝

	return 0;
}
```
![image](https://github.com/user-attachments/assets/f12b3649-4f56-410a-a31c-ef6e99b50f19)

### 스핀락 기법
![image](https://github.com/user-attachments/assets/61fa3123-8c28-40ca-b893-cf3b6e229e8b)

#### 스핀락(spinlock)기법
* busy-waiting lock기법
  * 스레드가 큐에서 대기하지 않고 락이 열릴 때까지 계속 락 변수 검사
* 뮤텍스와 거의 같고 busy-waiting이라는 점에서만 다름
  * 대기큐 없음
  * busy-waiting으로 인해 CPU를 계속 소무, PCU가 다른 스레드를 실행할 수 없음
* 락을 소유한 스레드만 자원 배타적 사용, 동기화 기법
  * 공유 자원 하나 당 하나의 스핀락 사용
 
#### 스핀락 기법의 구성 요소
1. 락 변수
  * true/false 중 한 값
  * true: 락을 잠근다. 락을 소유한다.
  * false: 락을 연다. 락을 해제한다.
2. 연산
  * lock연산
    * 임계구역에 들어갈 때 실행되는 entry코드
    * 락이 잠김 상태면, 락이 풀릴 때까지 무한루프 돌면서 lock연산 시도
    * 락이 열린 상태면 락을 잠김 상태로 바꾸고 임계구역 실행
  * unlock 연산
    * 임계구역을 나올 때 실행하는 exit코드
    * 락을 열림 상태로 변경

![image](https://github.com/user-attachments/assets/848d2a59-0553-4695-a5ca-30c07856f7b4)

1. T1스레드가 lock연산을 수행하여 락을 잠그고 임계구역을 실행한다.
2. T1이 임계구역을 실행하는 중에 T2가 스케줄되어 lock연산을 실행한다. lock연산은 락이 열림 상태가 될 때까지 반복하여 락을 검사하는 CPU명령들을 실행한다.
3. T1이 임계구역의 실행을 마치고 unlock연산을 수행한다. unlock연산으로 락을 열림상태로 만든 후, T1은 임계구역을 벗어나 실행을 계속한다.
4. T2는 반복된 락 검사 중 열림상태를 확인하고 락을 잠그고 임계구역으로 들어간다.

### 스핀락 특징
#### 스핀락을 이용한 동기화 특징
* 뮤텍스의 non-blocking 모델: 락이 잠겨있을 때 블록되지 않고 락이 풀릴 때까지 검사하는 코드 실행
* 단일 CPU(단일 코어)를 가진 운영체제에서 비효율적
  * 단일코어 CPU에서 의미 없는 CPU시간 낭비
    * 스핀락을 검사하는 스레드의 타임 슬라이스가 끝날 때까지 다른 스레드 실행 안됨, 다른 스레드의 실행 기회 뺏음
    * 락을 소유한 다른 스레드가 실행되어야 락이 풀림
  * 멀티코어에 적함
    * 락을 경쟁하는 스레드들을 서로 다른 코어에서 실행. 한 코어에서 임계구역을 실행 중일 때, 다른 코어에서 락이 풀릴 때까지 검사
* 임계구역의 실행 시간이 짧은 경우 효과적

#### 스핀락 동기화를 위한 POSIX 표준 라이브러리
* 스핀락 변수
  * pthread_spinlock_t lock;
* 스핀락 조작 함수들
  * pthread_spin_init(): 스핀락 변수 초기화
  * pthread_spin_lock(): 스핀락 잠그기
  * pthread_spin_unlock(): 스핀락 풀기
  * pthread_spin_destroy(): 스핀락 변수 사용 종료
 
![image](https://github.com/user-attachments/assets/251f90f5-37e4-4ca1-bca2-37bc0193521d)

### 탐구 6-3: pthread의 스핀락을 이용한 공유 집계판의 스레드 동기화
```c
#include <stdio.h>
#include <pthread.h>

int sum = 0; // 두 스레드가 공유하는  변수
pthread_spinlock_t lock; // 스핀락 변수 선언

void* worker(void* arg) { // 스레드 코드
	printf("%s 시작\t %d\n", (char*)arg, sum);
	for(int i=0; i<1000000; i++) {
		pthread_spin_lock(&lock); // entry 코드. 스핀락 잠그기
		sum = sum + 10; // 임계구역코드
		pthread_spin_unlock(&lock); // exit 코드. 스핀락 열기 
	}
	printf("%s 끝\t %d\n", (char*)arg, sum);
}
int main() {
	char *name[] = {"황기태", "이찬수"};
	pthread_t tid[2];
	pthread_attr_t attr[2]; // 스레드 정보를 담을 구조체

	pthread_attr_init(&attr[0]); // 디폴트 속성으로 초기화
	pthread_attr_init(&attr[1]); // 디폴트 속성으로 초기화

	pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE); // 스핀락 변수lock 초기화
	// lock 변수에 대한 접근을 현재 프로세스에 속한 스레드들로 제한

	pthread_create(&tid[0], &attr[0], worker, name[0]);  // 스레드 생성
	pthread_create(&tid[1], &attr[1], worker, name[1]); // 스레드 생성

	pthread_join(tid[0], NULL); // 스레드 종료 대기
	pthread_join(tid[1], NULL); // 스레드 종료 대기

	printf("최종 sum = %d\n", sum); // 두 스레드 종료 후 sum 출력

	pthread_spin_destroy(&lock); // 스핀락 lock 사용 끝

	return 0;
}
```
![image](https://github.com/user-attachments/assets/48e4af6c-e4f7-423f-b646-2506f4cb994c)

### 뮤텍스와 스핀락은 어떤 경우에 적합한가?
1. 락이 잠기는 시간이 긴(임계구역이 긴) 응용: 뮤텍스
  * 락을 얻지 못했을 때, CPU를 다른 스레드에게 양보하는 것이 효율적
  * 락이 잠기는 시간이 짧은 경우: 스핀락이 효율적
2. 단일 CPU를 가진 시스템: 뮤텍스
  * 단일 CPU에서 스핀락은 크게 의미 없음
3. 멀티코어(멀티CPU)를 가진 시스템: 스핀락
  * 임계구역은 보통 짧게 작성되므로
  * 잠자고 깨는 컨텍스트 스위칭 없이 바로 자원 사용
4. 사용자 응용 프로그램: 뮤텍스, 커널 코드: 스핀락
  * 커널 코드나 인터럽트 서비스 루틴은 빨리 실행되어야 하고,
  * 인터럽트 서비스 루틴 내에서 잠잘 수 없기 때문
5. 스핀락을 사용하면 기아 발생 가능
  * 스핀락은 무한 경쟁 방식이어서 기아 발생 가능
  * 락을 소유한 스레드가 락을 풀지 않고 종료한 경우나 코딩이 잘못된 경우에도 기아 발생 가능
![image](https://github.com/user-attachments/assets/3a7e264b-fd91-4475-a01d-2e0e58f73667)
