### 세마포의 필요성을 이해하기 위한 대여 시스템 사례: 여러 자원을 여러 명이 사용하는 경우
![image](https://github.com/user-attachments/assets/aef9ab2b-4b68-4bf3-be64-08650d337d39)

a. 12개의 방을 갖춘 실세계의 세미나실 예약 시스템의 모습
* 현재 8개의 방이 이용되고 있으며 사용 가능한 방의 수와 대기자 수를 나타내는 팻말이 붙어 있다.
* 학생이 세미나실을 사용하려면 사용가능한 방의 수를 3으로 고치고 세미나 방을 사용하면 된다.
* 만일 12개의 방이 모두 사용 중이면 대기자수를 1로 고치고 대기 줄에서 기다린다.
* 그림 b는 실세계를 프로그램 세계로 옮겨놓은 것이다.
* 사용 가능한 방의 개수를 카운터 변수로, 학생 대기줄은 대기 큐로 나타내었다.

### 세마포가 필요한 상황
![image](https://github.com/user-attachments/assets/24cb6c95-9243-4972-9a59-71138e341ea9)

* n개의 자원이 있는 상황에서 멀티스레드가 자원을 사용하려고 한다.
* 자원이 모두 동날 때, 자원을 사용하련ㄴ 스레드는 기다려야 하고, 자원을 다 사용한 스레드는 이를 알려 대기 중인 스레드가 자원을 사용할 수 있도록 관리하는 주체가 필요하다.
* 세마포가 바로 이 일을 하도록 제안되었다.
* 세마포는 자원의 개수 n을 알고, 스레드의 요청을 받아 사용을 허락하고, 자원이 모자랄 떄 요청한 스레드는 대기 큐에서 잠을 재우며, 자원 사용을 끝낸 스레드가 세마포에게 알리면 세마포가 대기 큐에서 잠을 자는 스레드를 꺠워 자원을 사용하도록 허락하는 방식이다.

### 세마포
#### 정의
* 멀티스레드 사이의 자원 관리 기법
  * n개의 공유 자원을 다수 스레드가 공유하여 사용하도록 돕는 자원 관리 기법
    * n개의 공유 자원을 다수 스레드가 공유하여 사용하도록 돕는 자원 관리 기법
      * n개의 프린터가 있는 경우, 프린터를 사용하고자 하는 다수 스레드의 프린터 사용 관리
#### 구성 요소
1. 자원: n개
2. 대기 큐: 자원을 할당받지 못한 스레드들이 대기하는 큐
3. counter 변수
  * 사용 가능한 자원의 개수를 나타내는 정수형 전역 변수
  * n으로 초기화(counter=n)
4. P/V연산
  * P 연산(wait연산): 자원 요청 시 실행하는 연산(--)
    * 자원 사용 허가를 얻는 과정
  * V 연산(signal연산): 자원 반환 시 실행하는 연산(++)
    * 자원 사용이 끝났음을 알리는 과정
   
### 세마포를 이용한 멀티스레드 자원 관리의 구조
* 4개의 인스턴스를 가진 자원에 대해, 4개의 스레드(T1\~T4)가 할당 받아 사용,
* 2개의 스레드 T5와 T6는 자원을 기다리고 있는 상태
* counter변수는 사용 가능한 자원의 개수를 나타내지만 음수이면 대기 중인 스레드의 수를 나타냄

![image](https://github.com/user-attachments/assets/0763f628-1281-44c7-ad00-9aa5c0132448)

### P연산과 V연산
#### 세마포 종류 2가지 - sleep-wait 세마포와 busy-wait세마포
  * 자원을 할당받지 못한 경우의 행동에 따라 구분
#### sleep-wait세마포
* P연산: counter--, 대기 큐에서 잠자기
* V연산: counter++, 사용 가능 자원이 있으면 잠자는 스레드 깨우기
#### busy-wait 세마포
* P연산: 사용 가능 자원이 생길 때까지 **무한 루프** 후 자원이 생기면 counter--
* V연산: counter++

![image](https://github.com/user-attachments/assets/867d5049-b3ff-4743-a493-aa6127e395fd)

### 세마포 활용을 위한 POSIX 표준 라이브러리
#### 세마포 구조체
* sem_t s;//counter 변수 등을 가진 세마포 구조체
#### 세마포 조작 함수들
* sem_init(): 세마포 초기화
* sem_destroy(): 세마포 기능 소멸
* **sem_wait()**
  * P연산을 수행하는 함수(blocking call)
  * sleep-wait방식으로, 가용 자원이 없으면 대기 큐에서 잠을 잠
* sem_trywait()
  * P연산을 수행하는 함수(non-blocking call)
  * 가용 자원이 있으면, counter값을 감소시키고 0 리턴
  * 없으면, counter값을 감소시키지 않고 -1 리턴
* sem_post()
  * V연산을 수행하는 함수
* sem_getvalue()
  * 세마포의 현재 counter값을 리턴하는 함수
 
![image](https://github.com/user-attachments/assets/208e2264-31c1-4182-9dd3-1a6a504d1e33)

### 탐구 6-4. 세마포 활용 사례
```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

sem_t toiletsem; // POSIX 세마포 구조체로 모든 스레드에 의해 공유

void* guest(void* arg) { // 고객의 행동을 묘사하는 스레드 코드
    int cnt = -1;

    sem_wait(&toiletsem); // P 연산. 자원 사용 요청. 세마포의 counter 값 1 감소
    sem_getvalue(&toiletsem, &cnt); //  세마포의 counter 을 cnt 변수로 읽어오기
    printf("고객%s 화장실에 들어간다... 세마포 counter = %d\n", (char*)arg, cnt);

    sleep(1); // 1초 동안 화장실을 사용한다.

    printf("고객%s 화장실에서 나온다.\n", (char*)arg);
    sem_post(&toiletsem); // V 연산. 화장실 사용을 끝냈음을 알림
}

#define NO 0          // 자식 프로세스와 세마포 공유하지 않음
#define MAX_COUNTER 3 // 자원의 개수, 동시에 들어갈 수 있는 스레드의 개수

int main() {
    int counter = -1;
    char *name[] = {"1", "2", "3", "4", "5"};
    pthread_t t[5]; // 스레드구조체

    // 세마포 초기화 : MAX_COUNTER 명이 동시에 사용
    int res = sem_init(&toiletsem, NO, MAX_COUNTER);
    if(res == -1) {
        printf("semaphore is not supported\n");
        return 0;
    }
    sem_getvalue(&toiletsem, &counter); //  세마포의 현재 counter 값 읽기
    printf("세마포 counter = %d\n", counter);

    for(int i=0; i<5; i++)
        pthread_create(&t[i], NULL, guest, (void*)name[i]); // 5명의 고객(스레드) 생성

    for(int i=0; i<5; i++)
        pthread_join(t[i],NULL); // 모든 고객이 소멸할 때까지 대기

    sem_getvalue(&toiletsem, &counter); //  세마포의 현재 counter 값 읽기
    printf("세마포 counter = %d\n", counter);
    sem_destroy(&toiletsem); //세마포 기능 소멸

    return 0;
}
```
![image](https://github.com/user-attachments/assets/49fb169d-861b-4651-a562-d00ea6856140)

### 카운터 세마포와 이진 세마포
#### 카운터 세마포(counter semaphore)
* 여러 개의 자원을 관리하는 세마포(앞서 설명)
#### 이진 세마포(binary semaphore)
1. 세마포 변수 S
  * 0과 1중 하나를 가지는 전역 변수, S는 1로 초기화
2. 대기 큐
  * 사용 가능한 자원이 생길 때까지 스레드들이 대기하는 큐
  * 스레드 스케줄링 알고리즘 필요
3. 2개의 원자 연산
  * wait연산(P연산): 자원 사용 허가를 얻는 과정
    * s를 감소시키고, 0보다 작으면 대기 큐에서 잠듦. 0보다 크거나 같으면, 자원 사용하는 코드 실행
  * signal 연산(V연산): 자원 사용이 끝났음을 알리는 과정
    * S를 증가시키고, 0보다 크면 그냥 리턴, 0보다 작거나 같으면 대기 큐에 있는 스레드 중 하나를 깨움
   
### 동기화 이슈: 우선순위 역전
#### 우선순위 역전
* 스레드의 동기화로 인해 높은 순위의 스레드가 낮은 스레드보다 늦게 스케줄링 되는 현상
  * 우선순위를 기반으로 스케줄링하는 실시간 시스템에서 스레드 동기화로 인해 발생
#### 우선 순위 역전 현상 사례
![image](https://github.com/user-attachments/assets/a0835866-e8f7-4705-bfc3-74ed07ea602c)

#### 우선순위 역전의 문제점
* 실시간 시스템의 근본 붕괴
  * 우선순위가 높다는 것은 중요한 일을 할 가능성이 높은데, 높은 순위의 스레드(T3)가 늦게 실행되면 심각한 문제 발생 가능
  * 낮은 순위의 스레드(T2)가 길어지면 더욱 심각한 문제 발생
 
### 우선순위 역전 해결책
#### 2가지 해결책
* 우선순위 올림(priority ceiling) (ceiling: 천장, 한계, 한도)-> 천장에 올려라
  * 스레드(T1)가 공유 자원을 소유하게 될 때, 스레드의 우선순위를 미리 정해진 높은 우선순위로 일시적으로 올림
  * 선점되지 않고 빨리 실행되도록 유도
* 우선순위 상속(priority inheritance)
  * 낮은 순위의 스레드(T1)가 공유 자원을 가지고 있는 동안,
  * 높은 순위의 스레드(T3)가 공유 자원을 요청하면,
  * 공유 자원킴
