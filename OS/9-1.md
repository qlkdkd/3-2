# 9. 페이징 메모리 관리
## 1. 페이징 메모리 관리 개요
### 페이징 개념
#### 페이징과 프레임
* 프로세스의 주소 공간을 0번지부터 동일한 크기의 페이지(page)로 나눔)
  * 코드, 데이터, 스택 등 프로세스의 구성 요소에 상관없이 0번지부터 고정 크기로 분할한 단위
* 물리 메모리 역시 0번지부터 페이지 크기로 나누고, 프레임(frame)이라고 부름
* 페이지와 프레임에 번호 붙임
* 페이지의 크기
  * 주로 4KB 운영체제마다 다르게 설정 가능, 2^n즉, 4KB, 8KB, 16KB 등
* 페이지 테이블
  * 각 페이지에 대해 페이지 번호와 프레임 번호를 1:1로 저장하는 테이블

#### 페이징 기법
* 프로세스의 주소 공간과 물리 메모리를 페이지 단위로 분할하고, 프로세스의 각 페이지를 물리 메모리의 프레임에 분산 할당하여 관리하는 기법
* 프로세스의 주소 공간
  * 0에서 시작하여 연속적인 주소 공간
* 프로세스마다 페이지 테이블 있음
* 논리 주소의 물리 주소 변환: MMU에 의해
* 물리 메모리의 빈 프레임 리스트 관리 필요
  * 프레임 할당 알고리즘: 빈 프레임 중에서 선택하는 알고리즘 필요
* 내부 단편화 발생
* 세그먼테이션보다 우수

### 논리 페이지와 물리 프레임의 매핑

![image](https://github.com/user-attachments/assets/7c077027-447d-4bb6-8f9c-d4898170575a)

* 그림 9-1은 물리 메모리가 프레임으로 분할되어 있는 것과, 프로세스의 각 페이지가 페이지 테이블을 통해 물리 프레임에 매핑된 사례를 보여준다.
* 페이지 테이블의 각 항목(PTE, Page Table Entry)에는 페이지의 프레임 번호가 기록된다.
  * 예를 들어, 프로세스1의 페이지0은 프레임 7에, 프로세스 페이지1은 프레임 1에 저장되어 있다.
* 프로세스의 주소 공간은 논리 주소 0번지부터 시작하여 이어져 있지만, 프로세스는 물리 메모리의 여러 프레임에 분산 할당되엉 있다.
* 프로세스마다 페이지와 물리 프레임을 매핑하는 페이지 테이블이 존재하며, MMU장치는 페이지 테이블을 이용하여 논리 주소를 물리 주소로 변환한다.

### 페이징의 우수성
#### 1. 용이한 구현
* 메모리를 0번지부터 고정크기의 페이지 단위로 단순 분할하기 때문
#### 2. 높은 이식성
* 페이징 메모리 관리를 위해 CPU에 의존하는 것 없으므로 다양한 컴퓨터 시스템에 쉽게 이식 가능
#### 3. 높은 융통성
* 시스템이나 응용에 따라 페이지 크기 다르게 설정 가능
#### 4. 메모리 활용과 시간 오버헤드 면에서 우수
* 외부 단편화 없음
  * 외부 단편화로 인한 메모리 낭비가 없고,
  * 홀 선택 알고리즘을 실행할 필요 없음
* 내부 단편화는 발생하지만 매우 작음

### 페이지와 페이지 테이블
![image](https://github.com/user-attachments/assets/819238dd-fe58-4d68-be6d-de227bbd308a)

* 4GB 주소 공간을 가지는 프로세스
* 페이지 크기 4KB
* 사례 프로세스
  * 코드: 페이지0\~페이지2에 걸쳐있음
  * 데이터: 페이지2\~페이지3에 걸쳐있음
  * 힙: 페이지3\~페이지4에 걸쳐있음
  * 스택: 사용자 공간의 맨 마지막 페이지에 할당, 한 개 페이지 사용
* 사례 프로세스는 6개 페이지 사용
  * 프로세스의 크기: 6\*4KB=24KB
* 페이지 테이블
  * 페이지 테이블은 주소 공간의 모든 페이지를 나타낼 수 있는 항목들을 포함
  * 현재 6개의 항목만 사용. 대부분의 항목은 비어있음

###  프로세스가 200바이트를 동적 할당 받을 때
```c
char *p=(char*)malloc(200); //프로세스의 힙 영역에서 200바이트 동적 할당
```
* 200바이트 할당
    * 한 페이지(4KB) 할당
  * 논리 페이지 5 할당, 물리 프레임 2 할당
    * 페이지 5의 논리 주소: 5\*4KB=20KB=20\*1024=20480번지
    * 프레임 2의 물리 주소: 2\*4KB=8192번지
  * 페이지 테이블 항목 5에 물리 프레임 번호 2 기록
  * malloc(200)은 논리 주소 20480(페이지 번호 5)을 리턴
 
```c
*p=a;
```
* 프로세스 내에서 20480번지에 'a'를 저장하는 코드
  * 논리 주소 20480이 MMU에 의해 물리 주소 8192로 바뀌어,
  * 물리 메모리 8192번지에 'a' 저장
```c
free(p);
```
* 20480번지부터 200바이트 반환
  * 반환 후 페이지 5 전체가 비게 되므로, 페이지 5와 프레임 2가 모두 반환
 
### 시스템 호출 시 프로세스의 페이지 테이블 활용
![image](https://github.com/user-attachments/assets/6ba440ac-5e22-4f55-86da-030d1995f1fb)

* 커널 공간의 페이지 k에 담긴 커널 코드 실행
* 커널 코드 역시 논리 주소로 되어 있음
* 현재 프로세스 테이블에서 페이지 k의 물리 프레임 780090을 알아내고 물리 프레임 78009에 적재된 커널 코드 실행

* 중요 사항
  * 커널 코드도 논리 주소로 되어 있음
  * 시스템 호출을 통해 커널 코드가 실행될 때, 현재 프로세스의 페이지 테이블을 이용하여 물리 주소로 변환
 
### 페이지와 페이지 테이블에 대한 정리
#### 32비트 CPU에서, 페이지 크기가 4KB인 경우
* Q1. 물리 메모리의 최대 크기는 얼마인가?
  * 물리 주소의 범위는 0\~2^32-1
  * 한 주소당 한 바이트 크기이므로 물리 메모리의 최대 크기는 2^32=4GB
* Q2. 프로세스의 주소 공간의 크기는 얼마인가?
  * 2^32개의 주소들(한 주소당 1바이트)이므로, 총 4GB
  * 물리 메모리는 1GB, 2GB, 4GB등 다양하게 설치될 수 있지만, 프로세스의 주소 공간은 물리 메모리 키기에 상관 없이 4GB
* Q3. 한 프로세스는 최대 몇 개의 페이지로 구성되는가?
  * 4GB/4KB=(2^32)/(2^12)=2^20개=1M개=약 100만개
* Q4. 프로세스당 하나의 페이지 테이블이 있다. 페이지 테이블의 크기는?
  * 페이지 테이블 항목 크기가 32비트(4B)라면(항목에는 프레임 번호 있음)
  * 4바이트\*2^20=2^22바이트=4MB
* Q5. 그림 9-2의 상황에서 프로세스가 사용자 공간에서 사용하고 있는 크기는?
  * 총 6개 페이지 사용
* Q6. 응용 프로그램이 하나의 프로세스라고 할 때, 응용프로그램의 최대 크기, 즉 개발자가 작성할 수 있는 프로그램의 최대 크기는?
  * 운영체제가 설정한 사용자 공ㅈ간의 크기와 동일
* Q7. 페이지 테이블 모양은?
  * 대부분의 항목이 비어있는 희소 테이블(sparse table). 낭비가 심해 줄이는 기법 필요
* Q8. 페이지 테이블은 어디에 존재하는가?
  * 메모리에 저장
* Q9. 커널 코드는 논리 주소로 되어있는가? 물리 주소로 되어있는가?
  * 커널 코드 역시 논리 주소로 되어 있음. 그러므로 커널 코드가 실행될 때 역시 물리 주소로 바뀌어야 하는데, 이때 현재 프로세스의 페이지 테이블 사용
 
### 페이징에서의 단편화
#### 외부 단편화 없음
#### 내부 단편화 발생
* 스택이나 힙에 생성하는 페이지는 계속 변하므로 단편화 계산에서 제외한다면,
* 프로세스의 마지막 페이지에만 단편화 발생
* 단편화의 평균 크기=페이지의 1/2크기

### 탐구 9-1. 페이징 개념 확인
### 32비트 CPU에서, 페이지 크기 2KB, 설치된 물리 메모리 1GB, 프로세스 A는 사용사 공간에서 54321바이트를 차지한다고 할 때,
* Q1. 물리 메모리의 프레임 크기는?
  * 2KB. 페이지 크기와 동일
 
* Q2. 물리 메모리의 프레임 개수는?
  * 물리 메모리를 프레임 크기로 나누면 됨. 1GB/2KB=2^30/2^11=2^19개, 약 50만개
 
* Q3. 프로세스의 주소 공간 크기와 페이지의 개수는
  * 프로세스의 주소 공간 크기는 2^32=4GB
  * 페이지의 개수=(2^32)/(2^11)=2^21=2M개=약 200만개
 
* Q4. 프로세스 A는 몇 개의 페이지로 구성되는가? 프로세스 A를 모두 적재하기 위한 물리 프레임의 개수는?
  * 프로세스 A의 실제 크기가 54321바이트이므로, 2KB(2048)로 나누면 54321/2048=26.5이므로, 27개 페이지로 구성되며, 물리 프레임 역시 27개 필요
 
* Q5. 페이지 테이블 항목 크기가 4바이트라고 할 때, 프로세스 A의 페이지 테이블 크기는?
  * 테이블 항목이 총 2^21개이므로 (2^21)\*4바이트=8MB
 
* Q6. 페이징에서 단편화 메모리의 평균 크기는?
  * 프로세스의 코드와 데이터 연속되어 있으므로, 마지막 페이지에만 단편화가 생긴다. 단편화 메모리의 평균은 페이지의 반이므로 1KB
 
* Q7. 페이지의 크기와 단편화의 관계는?
  * 페이지의 크기가 크면 단편화도 커진다.
 
* Q8. 페이지의 크기와 페이지 테이블의 크기 관계는?
  * 페이지 크기가 크면 페이지 개수가 작아지고 페이지 테이블의 크기도 작아진다.
 
## 2. 페이징의 주소 체계
### 페이징의 논리 주소
#### 논리 주소 구성
```
논리 주소=[페이지 번호(p), 오프셋(offset)]
```
  * 페이지 크기가 4KB(2^12)라면, 페이지 내 각 파이트 주소는 12비트
  * 오프셋 크기는 12비트
* 32비트 논리 주소 체계에서,
  * 상위 20비트는 페이지 번호
  * 하위 12비트는 오프셋
 
![image](https://github.com/user-attachments/assets/a9dceb27-6856-43f5-bca2-ca7aaa2b90cd)

![image](https://github.com/user-attachments/assets/edb407be-2fb6-438f-95c4-0578dad85b54)

* 논리주소 0x12345678은 0x12345번 페이지의 0x678번째 바이트에 대한 주소

### 논리 주소의 물리 주소 변환
![image](https://github.com/user-attachments/assets/43bc92b2-ad01-4574-8c24-b05906f0db53)

* 논리 주소는 프로세스의 페이지 p의오프셋의 위치를 가리킴
* 페이지 테이블에는 프로세스의 모든 페이지에 대한 할당된 프레임 번호가 저장되기 때문에, p를 페이지 테이블의 인덱스로 하여 페이지 테입르 항목을 찾으면 페이지 p가 할당된 프레임 번호 f를 얻을 수 있다.
* 페이지 번호 p를 프레임 번호 f로 바꾸고 오프셋을 그대로 사용하면 논리 주소를 물리 주소로 바꿀 수 있다.

### 페이징 구현
1. 하드웨어 지원
* CPU의 지원
  * CPU에 페이지 테이블이 있는 물리 메모리 주소를 가진 레지스터 필요
    * Page Table Base Register(PTBR)
    * 이 레지스터는 운영체제에 의해 제어
* MMU장치
  * 논리 주소의 물리 주소 변환 장치
  * MMU는 CPU 패키지에 내장됨
 
2. 운영체제 지원
* 물리 프레임의 동적 할당/반환
  * 물리 메모리의 빈 프레임 리스트 생성, 관리 유지
  * 프로세스의 생성/소멸에 따라 동적으로 프레임 할당/반환
* 페이지 테이블 관리 기능 구현
  * 프로세스마다 페이지 테이블 생성, 관리 유지
  * 페이지 테이블이 저장된 물리 메모리 주소를 PCB에 저장
* 프로세스 실행 시
  * 페이지 테이블의 물리 메모리 주소를 CPU의 PTBR(Page Table Base Register)에 적재
 
## 3. 페이지 테이블의 문제점과 TLB
### 페이징 테이블의 문제점
#### 문제점 2가지
* 문제1. 1번의 메모리 액세스를 위한 2번의 물리 메모리 액세스
  * 페이지 테이블은 몇MB의 비교적 큰 크기로, 메모리에 저장
  * CPU가 메모리를 액세스할 때마다, 2번의 물리 메모리 액세스-> 실행 속도 저하시킴
```
페이지 테이블 항목 읽기 1번 + 데이터 액세스 1번
```
  * TLB사용으로 해결
* 문제2. 페이지 테이블의 낭비
  * 프로세스의 실제 크기는 매우 작기 때문에
  * 대부분의 페이지 테이블 항목이 비어 있는 문제
    * 페이지 테이블은 프로세스의 최대 크기를 기준으로 생성
  * '멀티 레벨 페이지 테이블'등의 방법으로 해결
 
### 메모리 액세스 시 2번의 물리 메모리가 액세스되는 과정
![image](https://github.com/user-attachments/assets/ea1b9309-0c82-44a2-bb77-85767722b8f9)

1. CPU가 메모리 액세스을 위해 논리 주소(페이지 2)를 발생시킨다.
2. MMU에 의해 논리 주소가 물리 주소로 바꾸는 작업이 시작된다. PTBR(Page Table Base Register)가 가리키는 페이지 테이블의 물리 주소와 논리 주소에 담긴 페이지 번호(페이지 번호2)를 더하여 페이지 페이블 항목의 물리 주소를 계산한다.
```
페이지 테입르의 항목 물리 주소=PTBR에 저장된 물리 주소+페이지 번호
```
3. (페이지 테이블 항목 읽기)이제, 물리 메모리에 저장된 페이지 테입르 항목을 읽어 와서 물리 주소의 변환이 완료된다. 페이지 테입르 항목에는 프레임 번호 7이 들어 있다.
4. (물리 메모리 액세스)MMU에 의해 논리 주소가 물리 주소로 바뀌고, 물리 주소가 CPU칩 바깥으로 출력된다. CPU는 물리 메모리에서 코드나 데이터를 액세스한다.

### 탐구 9-2. C프로그램이 실행될 때 메모리 액세스 과정 분석
```c
int n[100];//400바이트, 전역변수
int sum=0;//전역변수
...
for (int i=0; i<100; i++)
  sum+=n[i];
```
* 32비트 CPU, 페이지는 4KB
* 배열 n\[100\]의 논리 주소는 0x2000(페이지 2)부터 시작
* 배열 n\[100\]의 물리 주소는 0x7000(페이지 7)부터 시작
* 배열 n\[100\]의 크기는 400바이트이며 페이지 2에 모두 들어있음
* 페이지 테이블은 물리 메모리 0xA00번지부터 시작

![image](https://github.com/user-attachments/assets/300feb7e-c0cb-4f01-ac5d-29cc0fdda140)

* 그림 9-9는 for문에서 n\[i\]값을 읽는 동안 2번의 메모리 액세스가 일어나는 과정을 보여준다. 이 그림을 보면서, n[0], n[1], n[2] 등이 읽혀지는 과정을 알아보자.
  1. n[0]을 읽기 위해 0x2000의 논리 주소가 발생되면 물리 주소로 바꾸기 위해, **페이지 테이블 항목 2를 먼저 읽는다**. 항목의 크기가 4바이트라고 하면 항목 2의 물리 주소는 다음과 같다. 페이지 테이블 항목 2에 저장된 값 7을 이용하여 물리 주소 0x7000이 완성되고, 물리 메모리 0x7000에서 n[0]을 읽는다.
  2. 계속해서 n[1]을 읽기 위해 0x2004의 논리 주소가 발새오디고, **다시 페이지 테이블 항목 2를 읽고** 물리 주소 0x7004를 출력하여 n[1]을 읽는다.
  3. 이런 식으로 n[99]를 읽을 때까지 계속된다. n[i]를 읽기 위해 **페이지 테입르 액세스 1번, n[i] 액세스 1번으로 총 2번의 물리 메모리가 액세스**되며, for문이 실행되는 동안 이 과정이 반복된다.
 
![image](https://github.com/user-attachments/assets/c19083fb-804a-4622-82c4-da1e70d01c8a)

![image](https://github.com/user-attachments/assets/b6cf6bdd-ce51-4025-b2b8-a646a22d64e7)

### TLB를 이용한 2번의 물리 메모리 액세스 문제 해결
#### 문제해결 실마리
* 논리 주소를 물리 주소로 바꾸는 과정에서 페이지 테이블을 읽어오는 시간을 없애거나 줄이는 기법

### TLB(Translation Look-aside Buffer)
* 주소 변환 캐시(address translation cache)로 불림
  * 최근에 접근한 '페이지 번호와 프레임 번호'의 쌍을 항목으로 저장하는 캐시 메모리
* 위치
  * 현대 컴퓨터에는 MMU 존재
* TLB 캐시의 구조와 특징
  * [페이지 번호 p, 프레임 번호 f]를 항목으로 저장
  * 페이지 번호로 전체 캐시를 동시에 고속 검색, 프레임 번호 출력
    * content-addressale memory, associative memory라고 불림
  * 고가, 크기 작음(64\~1024개의 항목 정도 저장)
 
![image](https://github.com/user-attachments/assets/8454c494-8047-4667-a6ba-82b7f4d4376e)

### TLB를 활용한 메모리 액세스 과정
1. CPU로부터 논리 주소 발생
2. 논리 주소의 페이지 번호가 TLB로 전달
3. 페이지 번호와 TLB 내 모든 항목 동시에 비교
* TLB에 페이지 번호가 있는 경우, TLB hit
  * TLB에서 출력되는 프레임 번호와 offset값으로 물리 주소 완성
* TLB에 페이지 번호가 없는 경우, TLB miss
  * TLB는 miss신호 발생
  * MMU는 페이지 테이블로부터 프레임 번호를 읽어와서 물리 주소 완성
  * 미스한 페이지의 [페이지 번호, 프레임 번호]항목을 TLB에 삽입
 
### TLB를 가진 메모리 액세스 과정
![image](https://github.com/user-attachments/assets/e701041c-9800-4d23-b70e-8d070e672dbd)

1. CPU로부터 논리 주소가 발생된다.
2. 논리 주소의 페이지 번호(2)가 TLB로 전송된다.
3. 페이지 번호(2)와 TLB 내에 저장된 **모든 페이지 번호가 동시에 비교**된다. 일치하는 항목을 발견한 경우 **TLB 히트**라고 부르며 일치된 TLB항목의 프레임 번호(7)가 출력된다. 이 프레임 번호 7과 논리 주소의 offset이 합쳐져 물리 주소가 만들어지고 물리 주소가 출력되어 물리 메모리가 액세스되낟.
4. 일치되는 항목이 발경되지 않는 경우 **TLB 미스**라고 부른다. TLB미스가 발생하면 MMU는 물리 메모리의 페이지 테이블 항목에서 프렝미 번호 (7)을 읽어와 물리 주소를 완성하고 물리 메모리를 액세스한다. 동시에, 방금 미스한 페이지 번호 [페이지 번호(2), 프레임 번호(7)]쌍을 TLB에 새 항목으로 삽입한다.

**TLB를 사용하는 경우**, TLB 히트가 발생하면 바로 주소 변환이 일어나므로 페이지 페이블을 액세스하지 않고 **1번만 물리 메모리를 액세스**한다. 즉 CPU의 메모리 액세스 시간을 반으로 줄인다.

### 탐구 9-3. TLB가 있는 경우 C 프로그램 실행 과정 분석
```c
int n[100];//400바이트, 전역 변수
int sum=0;//전역 변수
...
for(int i=0;i<100;i++)
  sum+=n[i];
```
* 32비트 CPU, 페이지는 4KB
* 배열 n[100]의 논리 주소는 0x2000(페이지 2)부터 시작
* 배열 n[100]의 물리 주소가 0x7000(프레임 7)부터 시작
* 배열 n[100]의 크기는 400바이트이며 페이지 2에 모두 들어있음
* 페이지 테이블이 메모리의 0xA000번지에서 시작

CPU가 for문에서 sum+=n[i];를 실행하는 동안 n[0], n[1], n[2],... , n[99]가 순차적으로 읽혀지므로 논리 주소도 다음과 같이 순차적으로 발생한다.

```
0x2000
0x2004
0x2008
0x200c
...
0x218c
```
![image](https://github.com/user-attachments/assets/57408bad-7caa-4325-b9e3-214918209701)

1. n[0]의 값을 읽기 위해 논리 주소 0x2000(페이지2)이 발생되면 **TLB캐시가 먼저 검색**된다. TLB캐시가 처음에 비어 있어 **TLB미스**가 발생한다. 그러므로 페이지 테이블의 항목 2(0xA008번지)를 읽어 페이지 2의 프렝미 번호가 얼마인지 알아낸다. 페이지 2의 프레임 번호가 7이므로 0x7000번지의 물리 메모리를 액세스함과 동시에, [2, 7]항목이 **TLB캐시에 기록**된다.
2. 그 후 n[1]을 읽기 위해 논리 주소 0x2004(역시 페이지2)가 발생되면 전에 만든 항목 [2, 7]에서 **TLB히트**가 이루어지고 즉각 물리 주소 0x7004가 완성되어 물리 메모리 0x7004번지가 액세스된다.
3. n[2]에서 n[99]까지 모두 페이지 2에 들어있기 때문에 이들을 읽는 내내 **TLB 히트**가 이루어져서 페이지 테입르을 읽지 않고 물리 주소가 빠르게 완성된다.

#### 탐구 9-3을 통해 2가지 현상 발견
* TLB미스가 발생하는 첫 번째 경우에만 물리 메모리 2번 액세스(페이지 테이블+n[i]의 물리 메모리)
* 동일한 페이지를 연속하여 액세스하는 동안 TLB hit 계속 발생 - 페이지 테이블 액세스 횟수 줄여짐 - 성능 향상
