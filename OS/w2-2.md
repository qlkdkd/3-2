## 3. 커널과 시스템 호출

### 응용 프로그램의 자원접근 문제
#### 오늘날 운영체제는 다중 프로그래밍 운영체제
* 다수의 응용프로그램이 한 컴퓨터에서 동시 실행

#### 문제
* 응용 프로그램이 직접 컴퓨터 자원에 접근하면 충돌과 훼손 발생
  * 다른 응용프로그램이 적재된 메모리 훼손 가능
  * 다른 응용프로그램이 만든 파일 삭제 및 훼손 가능
  * 응용 프로그램이 커널이 적재된 영역 훼손 가능
 
#### 해결 방안
* 응용프로그램의 자원 접근 불허
  * 자원에 대한 모든 접근은 커널에만 부여
 
#### 구체적인 해결 방안
1. 메모리 공간을 *사용자 공간과 커널 공간으로 분리*
* 응용프로그램은 사용자 공간에 적재, 커널은 커널 공간에만 적재
2. CPU의 실행 모드를 *사용자 모든와 커널 모드로* 분리
* 응용프로그램은 사용자 모드에서만 실행, 커널 코드는 커널 모드에서만 실행
* 사용자 공간에서 커널 공간의 코드를 직접 접근하지 못하게 하기 위해
* 사용자 모드에서 커널 코드를 접근하면 응용프로그램 강제 종료
3. 응용프로그램이 커널 기능을 이용하고자 할 때, _시스템 호출을 이용해서만 커널 코드 이용_

### 사용자 공간과 커널 공간
#### 운영체제는 컴퓨터 메모리를 두 공간으로 분리
* 사용자 공간(user space): 모든 응용프로그램들이 나누어 사용하는 공간
  * 응용프로그램들이 적재되는 공간
* 커널 공간(kernel space): 커널만 사용할 수 있는 공간
  * 커널 코드, 커널 데이터 등 커널에 의해 배타적으로 사용되는 공간
  * 디바이스 드라이버 포함

> * 32비트 컴퓨터에서 2GB이상의 프로그램 돌릴 수 있는 이유: 프로그램은 storage에 저장

#### 분리 이유
* 커널 코드와 데이터를 악의적인 응용프로그램이나 코딩 실수로부터 지키기 위함

![image](https://github.com/user-attachments/assets/62a724ee-6d66-4e7f-a3c0-93f1cbbaeb90)

### 사용자 공간 크기
#### 사용자 공간 크기
* 한 응용프로그램의 최대 크기 결정
  * 프로그램(코드) + 데이터(전역변수) + 힙(동적할당) + 스택 합친 크기
  * 예) 32비트 윈도우 운영체제에서 사용자공간 2GB란-> 응용프로그램을 2GB크기 이상 개발할 수 없음

#### 사용자 공간의 주소 범위
* 응용프로그램은 운영체제가 설정한 사용자 공간의 주소 범위를 넘어설 수 없음
  * 예) 32비트 윈도우 운영체제에서, 응용프로그램은 $0_{16}~7FFFFFFF_{16}$범위의 주소를 넘어 액세스하면, 바로 종류(심각한 오류)
 
### 주소 공간은 가상 주소 공간
![image](https://github.com/user-attachments/assets/bc0222a2-fc24-4ca2-92f4-c9bde55f83d2)

* 주소 공간=사용자 공간+커널 공간
* 주소 공간은 가상 주소 공간
  * 물리 메모리의 주소 범위와 무관
 
* 가상 주소 공간
  * **사용자나 응용프로그램 관점에서** 보는 주소 범위
  * 사용자가 전체 메모리를 사용하고 있다고 착각
 
* 각 응용프로그램
  * 2GB의 사용자 주소 공간을 가짐
  * 사용자 코드와 데이터 최대 2GB
  * 0~7FFFFFFF의 2GB의 메모리 독점 사용 착각
 
* 커널 공간 - 2GB~4GB-1의 주소 범위
  * 8000000~FFFFFFF범위 주소 공간
  * 모든 응용프로그램은 **커널 공간 공유**
 
#### 2가지 의문
* 응용프로그램의 **사용자 공간 충돌?**
* 실제 물리 메모리가 **4GB보다 작은 경우** 어떻게?

![image](https://github.com/user-attachments/assets/575057ac-48a5-4489-a825-a83b4cd1d826)

> * 예를 들어 구세대 스마트폰 메모리를 생각해 보자.
> * 그당시 메모리는 256MB정도 되었을 것이다.
> * 여기에 512MB짜리 게임, 512MB짜리 인스타, 그리고 256MB짜리 넷플릭스를 실행시키고자 한다.
> * 그러면 컴퓨터에서는 프로그램들을 100MB씩 쪼개서 돌릴 것이다.
> * 이때 메모리에서 커널 공간을 156MB정도, 나머지는 사용자 공간으로 쓸 것이다.
> * 만약에 메모리의 크기가 더 컸더라면 프로그램의 용량을 쪼개는 정도는 더 줄어들거나 아예 쪼개지 않고 메모리에 올릴 수 있었을 것이다.
> * 메모리가 클수록 컴퓨터의 속도는 더욱 빨라진다.

### 2가지 의문에 대한 해결
#### **사용자 공간의 충돌 해결)** 가상 주소 공간을 물리 메모리에 매핑
* 각 응용프로그램의 가상 주소 공간을 물리 주소 공간으로 매핑
  * 매핑 테이블은 운영체제가 소유하고 관리
 
* 물리 메모리를 여러 응용프로그램의 사용자 공간이 나누어 사용
  * 실제 각 응용프로그램은 사용자 공간의 일부만 사용
 
* 커널 공간 역시 물리 메모리에 매핑
  * 각 응용프로그램의 매핑 테이블에 기록
  * 커널 공간에 대한 매핑 테이블 부분을 모든 응용프로그램에서 동일
 
#### **물리 메모리가 작은 경우에 대한 해결**: 물리 메모리가 부족하면
* 운영체제는 물리 메모리를 하드 디스크에 저장하여 물리 메로리의 빈 영역 확보(가상 메모리 기법)

![image](https://github.com/user-attachments/assets/4af90bfe-4b29-45dc-9660-58e74cfa1934)

![image](https://github.com/user-attachments/assets/6504a754-0b9a-4243-bfed-b00e6cdb0b1a)

### 사용자 모드와 커널 모드
#### CPU는 사용자 모드와 커널 모드 중 한 모드로 실행
* CPU내부에 모드 상태를 나타내는 '모드 레지스터'가 있음
#### 사용자 모드(user mode)
* CPU의 모드 비트: 1
* CPU는 사용자 공간에 있는 코드나 데이터를 액세스 하는 중
* CPU의 커널 공간 접근 불허-> 응용 프로그램으로부터 커널 영역 보호
* 특권 명령(privileged instruction)실행 불허
  * 특권 명령 - 입출력 장치 등 하드웨어나 시스템 중단 등 시스템 관련 처리를 위해 설계된 특별한 명령
 
#### 커널 모드(kernel mode, supervisor mode)
* CPU의 모드 비트=0
* CPU가 커널 공간에서 실행하는 중, 혹은 사용자 코드를 실행하는 중
* 특권 명령 사용 가능

### 사용자 모드와 커널 모드에서의 메모리 액세스
![image](https://github.com/user-attachments/assets/bd5a9f86-bdd7-41cf-9293-4dba80207041)

### 사용자 모드에서 커널 모드로 전환
#### 사용자 모드에서 커널 모드로 전환하는 경우
* 오직 2가지 경우 - 시스템 호출과 인터럽트 발생

#### 시스템 호출
* 시스템 호출을 실행하는 특별한 기계 명령에 의해 진행
  * 예) int 0x80/sysenter/trap/syscall 등 CPU마다 다름
* 기계명령이 CPU의 모드 비트를 커널 모드로 전환

#### 인터럽트
* CPU가 인터럽트를 수신하면 커널 모드로 자동 전환
  * 인터럽트 서비스 루틴이 커널 공간에 있기 때문
 
* CPU는 인터럽트 서비스 루틴 실행
* 인터럽트 서비스 루틴이 끝나면 CPU는 사용자 모드로 자동 전환

![image](https://github.com/user-attachments/assets/845044c4-ff69-40c8-a8df-6fd87f328c9a)

![image](https://github.com/user-attachments/assets/0f243630-bf3d-4cde-a6f8-bb80705063dd)

### 커널의 실체
#### 커널은 부팅 시에 커널 공간에 적재된 함수들과 데이터 집힙
* 커널은 컴파일된 바이너리 형태, 하드디스크 특정 영역에 저장, 부팅 시에 커널 공간의 메모리에 적재

#### 커널 코드는 함수들의 집합
* 커널의 존재 - 커널 모드에서 실행되는 함수들과 데이터들의 집합

![image](https://github.com/user-attachments/assets/9436ae05-4e10-404e-8822-912a76f67831)

#### 커널은 스스로 실행되는 프로세스인가? NO
* **커널은 함수들의 단순 집합, 시스템 호출을 통해 호출되는 함수들**
* 커널이 스케줄링한다(X)
  * 커널 프로세스가 실행되면서 주기적으로 스케줄링한다(X)
  * 시스템 호출과 인터럽트 서비스 루틴에 의해 커널 내 스케줄러 함수가 호출되어 실행(O)
#### 커널은 실행 중이다? NO
* 커널은 프로세스도 스레드도 아니므로 NO
* 커널이 실행 중이다(X)
  * 응용 프로그램이 시스템 호출을 하여 커널 코드를 실행해고 있다.(O)
  * 인터럽트가 발생하여 인터럽트 서비스 루틴이 실행되고 있다.(O)
 
#### 커널은 스택이나 힙을 가지는가? NO
* 커널은 스탭이나 힙을 가지는 주체가 아니다. 그러므로 NO
* 스택이나 힙을 가지는 주체는 프로세스나 스레드
* 스레드마다 사용자 스택과 커널 스택 소유
  * 스레드가 생성될 때 프로세스의 사용자 공간에 사용자 스택 할당
    * 사용자 코드가 실행되는 동안 활용
  * 스레드가 생성될 때 커널 공간에 커널 스택 할당
    * 스레드가 시스템 호출로 커널 코드를 실행할 때 스택으로 활용
   
### 응용 프로그램 빌딩
