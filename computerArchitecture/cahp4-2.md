## 4.5. 명령어 실행 과정
### 프로그래머 모델
* 프로그래머 모델: 어셈블러 프로그래머가 프로그램을 작성하기 위하여 알고 있어야 할 컴퓨터 구조

![image](https://github.com/user-attachments/assets/ec79fc9c-2a46-423f-a2b5-79df448b9d07)

* 기억 장치(RAM): 주기억장치는 한 개의 모듈로 만들어져 있고 용량은 256\*8비트이다. 주소버스는 8비트이고, 데이터 버스도 8비트이다.
* 프로그램 카운터(PC): 다음에 실행할 명령어가 저장된 기억장치를 주소를 저장한다. 기억장치 주소를 저장해야 하므로 프로그램 카운터의 크기는 8비트이다. 초기값은 0이다.
* 명령어 레지스터(IR): 현재 실행 중인 명령어에 대한 기계어 코드를 저장한다. 명령어 크기를 16비트로 가정하기 때문에, 명령어 레지스터의 크기는 16비트이다.
* 레지스터 파일(R0\~R15): 레지스터의 모음을 레지스터 파일이라고 한다. 중앙처리장치는 8비트 데이터를 저장하는 16개의 레지스터를 갖고 있다. 각 레지스터는 레지스터 번호로 지정한다. 따라서 한 개의 레지스터를 지정하는데 4비트가 필요하다.
* 연산기(ALU): 연산기는 레지스터에 대해서만 동작한다고 가정한다. 즉, 두 개의 레지스터에 있는 값을 연산하여 다시 레지스터로 기록한다.

### ToyCOM 명령어 형식
* 명령어 종류
  * 데이터 이동(전달)명령어: 동작코드를 나타내는 4비트, 레지스터 중 하나를 지정하는 4비트, 기억장치 주소를 지정하는 8비트로 구성된다.
  * 데이터 처리 명령어: 동작코드를 나타내는 4비트, 목적지 레지스터를 지정하는 4비트, 두 개의 소스 레지스터에 각각 4비트를 할당하낟.
  * 프로그램 제어 명령어는 고려하지 않는다.
 
* 오퍼랜드
  * 부호 없는 8비트 데이터만 고려한다.
 
![image](https://github.com/user-attachments/assets/cdcb6922-799f-4b1e-9ad1-44540e126f56)

### 명령어 집합
동작|기호|동작코드|동작설명
---|---|---|---
적재|load|0010(2h)|기억장치 주소에서 레지스터로 데이터를 적재한다.
저장|store|0011(3h)|레지스터의 값을 기억장치 주소로 저장한다.
더하기|add|1000(8h)|소스 레지스터의 값을 더하여 목적지 레지스터에 저장한다.
빼기|sub|1001(9h)|소스 레지스터에 대하여 목적지 레지스터에 저장한다.
AND|and|1010(ah)|소스 레지스터에 대하여 논리 AND연산을 수행한다.
OR|or|1011(bh)|소스 레지스터에 대하여 논리 OR연산을 수행한다.

* 앞 4비트: opcode, 두번째 4비트, 나머지 8비트: operand
* 예: 0010_0010_0001_0000: `load R2, Mem[10h]`
* 0011_0011_0001_1000: `store R3, Mem[18h]`
* 1000_0011_0011_0100: `add R3, R3, R4`

### 프로그램 실행 과정
#### 명령어 사이클
* 인출 단계: 다음과 같이 기억장치를 두 번 액세스하는 레지스터 전송문으로 표현할 수 있다. 인출단계가 끝나면, PC의 값은 2 증가한다.
> IR[7:0]<- Mem[PC], PC<- PC+1
> 
> IR[15:8]<- Mem[PC], PC<- PC+1

* 실행 단계: 명령어마다 다르다

### 예제 프로그램
![image](https://github.com/user-attachments/assets/66ed31c2-8b69-49aa-be67-c22bf639725d)

![image](https://github.com/user-attachments/assets/b357873a-5cf5-45f3-9edc-b53a1b9f323a)

* 기억장치 80h번부터 차례대로 저장된 데이터를 A, B, C, D라고 한다면, 예제 프로그램은 D=A+B+C를 실행한다.
* 프로그램의 A는 Mem[80h]와 같다.
* 실제 고급 프로그래밍 언어로 작성한 프로그램도 이 예제와 마찬가지로 변수를 기억 장치에 할당한다.
* 그림 3-18은 ToyCOM의 초기 상태를 보여준다.
* 레지스터의 값은 모두 0으로 초기화되어 있다.
* 그림 3-18의 오른쪽은 기억장치에 예제 프로그램이 저장된 상태를 보여준다.
* 예를들어, 0번지의 기계어 명령어인 2180h는 8비트씩 나누어 0번지에 80h, 1번지에 21h가 저장된다.

### 명령어 사이클

![image](https://github.com/user-attachments/assets/75f1815f-d5c7-40b2-a848-7b504e68f263)

* a1. load R1, A 인출단계: 실행 전 PC값이 00h이다. IR은 기억장치 Mem[00h]와 Mem[01h]에 들어있던 2180h로 변경되고, PC값은 02h로 증가한다.
* a2. load R1, A 실행단계: 제어장치는 IR의 명령어를 해석하여 실행한다. R1값은 기억장치 A의 값인 04h로 변경된다.

![image](https://github.com/user-attachments/assets/8e5dbdc7-250b-46fb-9019-a151d4157536)

* b1. load R2, B 인출단계: 실행 전 PC 값이 02h이다. IR은 기억장치 Mem[02h]와 Mem[03h]에 들어 있던 2281h로 변경되고, PC값은 04h로 증가한다.
* b2. load R2, B 실행 단계: 제어장치는 IR의 명령어를 해석하여 실행한다. R2값은 기억장치 B의 값인 06h로 변경된다.

![image](https://github.com/user-attachments/assets/34c4d1c7-6498-446a-8f0c-b27f93c42246)

* c1. add R3, R1, R2 인출단계: 실행 전 PC값이 04h이다. IR은 기억장치 Mem[04]와 Mem[05]에 들어 있던 8321h로 변경되고, PC값은 06h로 증가한다.
* c2. add R3, R1, R2 실행단계: 제어장치는 IR의 명령어를 해석하여 실행한다. 연산기에서 R1+R2를 실행하고 그 결과를 R3에 저장하여, R3값이 0ah로 변경된다.

![image](https://github.com/user-attachments/assets/3cd0e304-dd70-4fe4-92c7-d36723f36e97)

* d1. load R1, C 인출단계: 실행 전 PC값이 06h이다. IR은 기억장치 Mem[06h]와 Mem[07h]에 들어있던 2182h로 변경되고, PC값은 08h로 증가한다.
* d2. load R1, C 실행단계: 제어장치는 IR의 명령어를 해석하여 실행한다. R1값은 기억장치 C의 값인 03h로 변경된다.

![image](https://github.com/user-attachments/assets/f27e8fb0-f7fe-4ba3-ac7d-65eec0315077)

* e1. sub R3, R3, R1 인출단계: 실행 전 PC의 값이 08h이다. IR은 기억장치 Mem[08h]와 Mem[09h]에 들어 있던 9331h로 변경되고, PC값은 0ah으로 증가한다.
* e2. sub R3, R3, R1 실행단계: 제어장치는 IR의 명령어를 해석하여 실행한다. 연산기에서 R3-R1을 실행하고 그 결과을 R3에 저장하여, R3값이 07h로 변경된다.

![image](https://github.com/user-attachments/assets/13a48570-f9ee-4a99-b289-0ae127c94880)

* f1. store R3, D 인출단계: 실행 전 PC값이 0ah이다. IR은 기억장치 Mem[0ah]와 Mem[0bh]에 들어있던 3383으로 변경되고, PC값은 0ch로 증가한다.
* f2. store R3, D 실행단계: 제어장치는 IR의 명령어를 해석하여 실행한다. R3 값 07h가 기억장치 D로 저장되어, 기억장치 D의 값이 07h로 변경된다.
