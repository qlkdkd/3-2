## 5-3. 인터럽트
*	인터럽트: 컴퓨터 내부 또는 외부에서 발생하는 갑작스러운 사건에 대응하는 기능
인터럽트 개념
	* 인터럽트: 방해하다
*	인터럽트 요청: 강의를 진행하는 중에 갑자기 학생이 질문한다면  
  * 상태 저장: 강사는 설명하던 것을 잠시 멈추고 현재 강의 진도를 기억해 두고, 
  * 인터럽트 서비스: 학생의 질문에 답변한 후에
  *	인터럽트 서비스에 복귀: 질문 전에 강의하던 내용으로 돌아와 계속 강의를 진행한다.

### 인터럽트 종류
*	내부 인터럽트
  *	하드웨어 고장
  * 실행할 수 없는 명령어: 기억장치에서 인출한 명령어의 비트 패턴이 중앙처리장치가 실행할 수 있는 명령어로 정의되어 있지 않다면, 그 명령어를 실행할 수가 없다.
  * 명령어 실행 오류: 나누기 0
  * 사용 권한 위배: 사용자가 운영체제만 사용할 수 있는 자원을 액세스하거나 읽기 전용 파일을 갱신하려고 할 때 내부 인터럽트 발생
* 외부 인터럽트
  * 타이머 인터럽트: 컴퓨터는 주기적으로 수행하는 일이 있다. 컴퓨터 안에 있는 타이머는 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청한다. 컴퓨터는 이 사건을 기반으로 시간을 측정하고, 프로세스 실행 시간을 측정하여 프로세스를 스케줄하고, 주기적으로 수행할 작업을 실행시키는 등 중요한 운영체제 작업을 수행한다.
  * 입출력 인터럽트: 속도가 느린 입출력장치가 입출력 준비가 완료되었다는 것을 중앙처리장치에게 알리기 위하여 사용하는 인터럽트이다. 이 기능 덕분에 중앙처리장치는 속도가 느린 입출력장치가 데이터를 전송할 준비를 마쳤는지 검사하는 시간을 없앨 수 있다.
인터럽트 처리 과정
 
### 인터럽트 처리 기능
*	인터럽트 처리를 위해 필요한 상황
*	인터럽트 가능 플래그(Interrupt Enable Flag)
*	인터럽트 요청과 확인
  *	요청: 임의의 소스가 인터럽트를 요청한다.
  *	확인: 중앙처리장치는 인터럽트 요청을 인식하고, 인터럽트 소스에게 인터럽트를 확인하였음을 알려준다.
*	인터럽트 단계:
  *	상태 저장: 중앙처리장치는 프로그램 실행을 중단하고 현재 상태를 저장한다.
  *	인터럽트 서비스: 중앙처리장치는 인터럽트 소스가 요구한 작업을 실행한다.
*	인터럽트 서비스 루틴: 일반 프로그램
  *	인터럽트에서 복귀: 중앙처리장치는 원래 실행한던 프로그램으로 복귀한다.
 
### 인터럽트 처리 과정
![image](https://github.com/user-attachments/assets/a9052cdc-9523-4fb2-9f22-435ffec6f030)

*	중앙처리장치는 현재 N번째 명령어(명령어 N)을 처리하고 있다.
*	명령어 N을 처리하는 임의의 시점에 인터럽트 요청이 발생할 수 있다.
*	제어 장치는 실행 단계가 끝날 때마다 인터럽트가 요청되었는지 검사한다.
*	명령어 N의 실행이 끝나고 검사할 때, 인터럽트가 요청되었으므로 인터럽트 단계를 실행한다.
*	인터럽트 서비스 루틴도 기억장치에 적재되어 있는 프로그램이므로, 중앙처리장치는 명령어 사이클에 의하여 인터럽트 서비스 루틴을 실행한다.
*	중앙처리장치는 인터럽트 단계에서 다음과 같은 세 가지 작업을 수행한다.
  1.	현재 실행하던 프로그램으로 복귀할 때 필요한 콘텍스트(PC와 SR)를 스택에 저장
  2.	인터럽트를 요청한 소스를 확인하고, 해당 인터럽트 서비스 루틴의 시작 주소를 구함
  3.	PC에 인터럽트 서비스 루틴의 시작 주소를 적재

인터럽트 단계/리턴
*	인터럽트 단계
  *	Context(PC와 SR)을 스택에 저장
  *	Interrupt source를 확인하고 ISR의 시작 주소 확인
```
SP<- SP – [단어 크기] //PUSH PC
Mem[SP]<- PC 
SP<- SP – [단어 크기] //PUSH SR
Men[SP]<- SR
PC<- ISR 시작 주소 //PC 갱신
```
*	인터럽트 리턴
  *	인터럽트 서비스 루틴의 마지막 실행 명령어
```
SP<- Mem[SP] //POP SR
SP<- SP+[단어 크기]
PC<- Mem[SP] //POP PC
SP<- SP+[단어 크기]
```

### 예제 5-6. 인터럽트 단계 전/후 상태
![image](https://github.com/user-attachments/assets/f48b85c7-d3fb-456c-81b5-9a432319a116)

### 인터럽트 가능 플래그
* 컴퓨터의 상태 변화
	* 시스템 리셋 후: 인터럽트 불가능 상태
	* 초기화 과정(부트로더)
 		* 시스템 스택 설정
   * 인터럽트 서비스 루틴 적재
   * 인터럽트 벡터 설정
  		* 인터럽트 벡터: 인터럽트 서비스 루틴의 시작 주소
    	* 인터럽트 벡터 테이블: 여러가지 인터럽트에 대한 인터럽트 벡터를 모아 놓은 기억장치 영역
	* 인터럽트 허용 상태로 전환
* IE flag
	* 상태 레지스터에 있는 제어 플래그 중 하나
	* 중앙처리장치가 인터럽트를 허용할지 제어

![image](https://github.com/user-attachments/assets/4be9a2bb-84bc-4749-a39a-a24e43619d65)

### 인터럽트 제어
* IE 제어 명령어
	* STI(Set Interrupt Flag)
 		* IE<- 1, 인터럽트 요청을 인식함
  * CLI(Clear Interrupt Flag)
  	* IE<- 0, 인터럽트 요청을 인식하지 않음
* 임계 영역(critical section)
	* 프로그램 중 실행이 중단되었다가 다시 시작되면 문제가 발생하는 영역
 	* IE제어명령어로 보호한다.
 
### 인터럽트 서비스 루틴
* 인터럽트 서비스 루틴
	* 인터럽트 요청을 해결하는 프로그램
 	* Interrupt Handler라고도 함
 
* 인터럽트 처리 순서

![image](https://github.com/user-attachments/assets/6cb48ac2-2459-4b8a-bcfa-145863558261)

1. 프로그램 실행 중: 현재 임의의 프로그램이 실행 중이다. 기억 장치에 적재되어 실행하고 있는 프로그램을 프로세스라고 한다.
2. 인터럽트 요청: 중앙처리장치가 N번째 명령어를 실행하고 있는 도중에 인터럽트 소스가 인터럽트를 요청한다. 중앙처리장치는 N번쨰 명령어의 실행단계를 마치고 나서 인터럽트 요청을 검사하고, 명령어 사이클의 인터럽트 단계로 들어간다.
3. 인터럽트단계: 인터럽트 소스에게 인터럽트가 확인되었음을 알리고(interrupt acknowledge), 콘텍스트(프로그램 카운터와 상태 레지스터)를 시스템 스택에 저장하고, 인터럽트 서비스 루틴의 시작 주소를 프로그램 카운터에 저장한다.
4. 인터럽트 서비스 루틴 실행: 명령어 사이클에 따라 인터럽트 서비스 루틴의 명령어들을 실행한다.
5. 인터럽트 리턴: 인터럽트 서비스 루틴의 마지막 명령어는 IRET(return from Interrupt)이다. 이 명령어를 실행함으로써 콘텍스트를 복구한다.
6. 프로그램 재개: 중앙처리장치는 실행이 중단되었던 프로세스의 N+1번째 명령어부터 다시 실행한다.

## 5-4 . 명령어 사이클
* 명령어 사이클의 기본 구성: 인출 단계/실행 단계/인터럽트 단계
* 프로세서마다 명령어 사이클의 실행단계를 세분화
	* 해독 단계: 명령어 코드를 해석
	* 기록 단계: 명령어 실행 결과를 레지스터나 기억장치로 저장
 	* 간접 단계: 기억 장치에서 데이터 인출
 
![image](https://github.com/user-attachments/assets/06c26a4a-68de-473a-9db3-c92c611b0619)
