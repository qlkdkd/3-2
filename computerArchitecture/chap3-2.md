## 3.4. 순서 논리 회로
### 1. 순서 논리 회로의 개요
* 조합 논리회로: 이전 입력 값에 관계 없이 현재 입력 값에 따라 출력이 결정
* 순서 논리회로: 현재의 입력 값과 이전 출력 상태에 따라 출력 값이 결정

![image](https://github.com/user-attachments/assets/4a4fad9a-c08d-40bf-b8f6-63d61388c587)

#### 순서 논리회로의 특징
* 순서 논리 회로의 출력은 외부에서 들어온 입력과 이전 출력 상태에 따라 결정된다. 이러한 동작은 클록 펄스가 들어올 때마다 반복해서 일어난다.
* 순서 논리 회로는 기억 기능(플립플롭)이 있다.
* 대표적인 순서 논리 회로에는 플립플롭, 카운터, 레지스터 등이 있다.

#### 클록 펄스
* 플립플롭(flip-flop)은 클록펄스(Clock Pulse)라는 제어 입력을 가지며, 출력은 클록 펄스에 동기되어 변하고 이러한 변화를 트리거(trigger)되었다고 한다.
![image](https://github.com/user-attachments/assets/2ec0fa52-324a-405b-a3b7-87f200cf7ff3)

#### 펄스 전이 검출기
* 실제 회로에서 클록 펄스는 상승 에지나 하강 에지에서 순간적으로 1이 되는 날카로운 파형을 만들어 플립플롭을 동작시키는데, 이 파형을 에지 트리거(edge trigger)라고 한다.
* 클록 펄스(구형파)로 에지 트리거를 만들려면 펄스 전이 검출기가 필요하다.

![image](https://github.com/user-attachments/assets/be6a3853-056a-40e3-b1de-d0c71fc40ea2)

### 플립플롭의 종류
#### 플립플롭의 특징
* 플립플롭은 1비트의 정보를 기억할 수 있는 기억 소자다.
* 플립플롭은 제어 입력인 클록 펄스가 있으며 다음 클록 펄스가 들어올 때까지 현재 상태를 유지한다.
* 플립플롭은 Q와 Q'로 표시된 출력이 2개 있으며 Q와 Q'의 상태는 서로 보수가 되어야 정상 상태가 된다.
* 플립플롭은 RAM의 구성요소로도 사용된다.
* 플립플롭에는 SR플립플롭, JK플립플롭, D플립플롭, T플립플롭이 있다.

![image](https://github.com/user-attachments/assets/52db6229-a10e-4714-b532-75d51e14707c)

![image](https://github.com/user-attachments/assets/0dbe0d83-3958-4608-b7e6-8bc528407769)

#### SR 플립플롭
* SR플립플롭: 클록 펄스가 있을 때만 동작하는 SR 래치를 의미
* 클록 펄스는 상승 에지 트리거 신호가 입력된 경우다.
![image](https://github.com/user-attachments/assets/771657da-f933-4745-a81b-6052e614b6fd)

* CP=0인 경우: S와 R이 입력에 관계 없이 앞단의 AND게이트 G3과 G4의 출력이 항상 0이므로 플립플롭의 출력은 불변
* CP=1인 경우: S와 R이 입력이 회로 후단의 NOR게이트 G1과 G2의 입력으로 전달되어 SR래치와 같은 동작을 수행

#### SR 플립플롭의 특성표 및 특성 방정식
![image](https://github.com/user-attachments/assets/4101dabe-e983-4889-b053-24a412c9aee4)

#### D플립플롭
* SR플립플롭에서 원하지 않는 상태(S=R=1)를 제거하는 한 가지 방법
* SR플립플롭을 변형한 것
* 입력신호 D가 CP에 동기되어 그대로 출력에 전달되는 특성을 가지고 있음
* D플립플롭이라는 이름은 데이터(Data)를 전달하는 것과 지연(Delay)하는 역할에서 유래

![image](https://github.com/user-attachments/assets/215c1821-6f22-446c-bdef-52104165d436)

* CP=1, D=1: G3의 출력은 0, G4의 출력은 1이 된다. 따라서 SR래치의 입력은 S=0, R=1이 되므로 결과적으로 Q=1을 얻는다.
* CP=1, D=0: G3의 출력은 1, G4의 출력은 0이 된다. 따라서 SR래치의 입력은 S=1, R=0이 되므로 결과적으로 Q=0을 얻는다.

#### D플립플롭의 특성표 및 특성방정식
![image](https://github.com/user-attachments/assets/4737f44a-b326-4280-9b27-03b7869438d1)

#### JK플립플롭
* JK플립플롭은 SR플립플롭에서 S=1, R=1인 경우 출력이 불안정한 상태가 되는 문제점을 개선하여 S=1, R=1에서도 동작하도록 개선한 회로
* JK플립플롭의 J는 S(Set), K는 R(Reset)에 대응하는 입력
* J=1, K=1인 경우 JK플립플롭의 출력은 이전 출력의 보수 상태로 변화
* JK플립플롭은 플립플롭 중에서 가장 많이 사용되는 플립플롭이다.

![image](https://github.com/user-attachments/assets/0f88a324-4b59-417a-8825-19c4036c00b6)

1. J=0, K=0: G3과 G4의 출력이 모두 0이 되므로 G1과 G2로 구성된 SR래치는 출력이 변하지 않는다.
2. J-0, K=1: G4의 출력은 0이 되고 G3의 출력은 Q(t)가 된다. Q(t)=1이면 G(3)의 출력은 1이므로 SR래치의 S=0, R=1인 경우와 같아 출력은 Q(t+1)=0이 된다. Q(t)=0이면 G3의 출력은 0이므로 SR래치의 S=0, R=0인 경우와 같아 출력은 변하지 않으므로 Q(t+1)=0이 된다. 결과적으로 J=0, K=1이 입력되면 이전상태 Q(t)와 관계 없이 Q(t+1)=0이 된다.
3. J=1, K=0: G3의 출력은 0이 되고 G4의 출력은 Q'(t)가 된다. 이 경우 Q'(t)=0이면 G4의 출력은 0이므로 SR래치의 S=0, R=0인 경우와 같아 출력은 변하지 않고 Q(t+1)=1이 된다. Q'(t)=1이면 G4의 출력은 1이므로 SR래치의 S=1, R=0인 경우와 같아 출력은 Q(t+1)=1이 된다. 결과적으로 J=1, K=0이 입력되면 이전상태 Q(t)에 관계 없이 Q(t+1)=1이 된다.
4. J=1, K=1: G3의 출력은 Q(t)가 되고 G4의 출력은 Q'(t)가 된다. Q(t)=0인 경우 SR래치의 S=1, R=0인 경우와 같아 출력은 Q(t+1)이 된다. 마찬가지로 Q(t)=1인 경우 SR래치의 S=0, R=1인 경우와 같아 출력은 Q(t+1)=0이 된다. 결과적으로 출력 Q(t+1)은 이전 상태 Q(t)의 보수가 된다.

![image](https://github.com/user-attachments/assets/0de0b899-2c35-4508-9424-4cd1e10aaf83)

#### T플립플롭
* JK플립플롭의 J와 K 입력을 묶어서 하나의 입력신호 T로 동작시키는 플립플롭
* T플립플롭의 입력 T=0이면, T플립플롭은 J=0, K=0인 JK플립플롭과 같이 동작하므로 출력은 변하지 않는다.
* T=1이면 J=1, K=1인 JK플립플롭과 같이 동작하므로 출력은 보수가 된다.

![image](https://github.com/user-attachments/assets/32f4c436-649d-42d8-a7c8-d93f12b84221)

![image](https://github.com/user-attachments/assets/714b212d-e20a-4b9b-a92e-461694fc599a)

#### 주종형 JK플립플롭
* 레이스 현상 문제: JK플립플롭은 J=K=1인 경우 클록펄스가 길어지면 출력이 계속 반전되는 현상
* 이를 해결하는 방법은 에지 트리거를 이용하거나 주종형 JK플립플롭을 사용하는 것이다.

![image](https://github.com/user-attachments/assets/af74968f-e4e2-4aec-810c-dd07d7f1a96d)

* CP=1: 외부의 J와 K의 입력이 Master플립플롭에 전달. Slave플립플롭은 CP=0이므로 동작하지 않음
* CP=0: Slave플립플롭이 동작하여 Q=Y, Q'=Y'. Master플립플롭은 CP=0이므로 동작하지 않음

#### 비동기 입력
* 대부분의 플립플롭은 클록 펄스로 플립플롭의 상태를 변화시키는 동기 입력과, 클록펄스와 관계 없이 비동기적으로 변화시킬 수 있는 비동기 입력인 preset(P'R')과 clear(C'L'R')가 있다.
* 비동기 입력들은 플립플롭의 초기조건을 결정하는 등 다방면으로 유용하게 사용

![image](https://github.com/user-attachments/assets/91373195-af31-4c7c-b5ce-2d9456e97b89)

### 3. 순서논리회로의 설계
#### 여기표
* 플립플롭의 특성표: 현재 상태와 입력값이 주어졌을 때, 다음 상태가 어떻게 변하는가를 나타내는 표
* 플립플롭의 여기표: 현재 상태에서 다음 상태로 변했을 때 플립플롭으 입력 조건이 어떤 상태일가를 나타내는 표
* 플립플롭의 여기표는 순서논리회로를 설게할 때 자주 사용

![image](https://github.com/user-attachments/assets/1bc8d74f-8a8d-45c0-a1fb-4c1802f13af7)

1. Q(t)=0에서 Q(t+1)=0으로 변하는 경우는 S=0, R=0과 S=0, RE=1인 경우 두 가지다. 이것은 S=0, R=x로 표시한다.
2. Q(t)=0에서 Q(t+1)=1로 변하는 경우는 S=1, R=0인 경우만 변화가 가능하다.
3. Q(t)=1에서 Q(t+1)=0으로 변하는 경우는 S=0, R=1인 경우만 변화가 가능하다.
4. Q(t)=1에서 Q(t+1)=1로 변하는 경우는 S=0, R=0과 R=1, R=0인 경우이다. 이것은 S=x, R=0으로 표시한다.

![image](https://github.com/user-attachments/assets/cbc0deef-9166-4776-9ea8-84ccce7f7b06)

1. Q(t)=0에서 Q(t+1)=0으로 변하는 경우는 J=0, K=0과 J=0, K=1인 경우 두 가지다. 따라서 J=0, K=x로 표시한다.
2. Q(t)=0에서 Q(t+1)=1로 변하는 경우는 J=1, K=1과 J=1, K=0인 경우 두 가지다. 따라서 J=1, K=x로 표시한다.
3. Q(t)=1에서 Q(t+1)=0으로 변하는 경우는 J=1, K=1과 J=0, K=1인 경우 두 가지다. 따라서 J=x, K=1로 표시한다.
4. Q(t)=1에서 Q(t+1)=1로 변하는 경우는 J=0, K=0과 J=1, K=0인 경우 두 가지다. 따라서 J=x, K=0으로 표시한다.

![image](https://github.com/user-attachments/assets/b18fad14-1489-447b-a0f5-b11a18eb491a)

#### 순서 논리 회로의 설계 과정
1. 설계 사양으로부터 상태도와 상태표 작성
2. 플립플롭의 수와 종류 결정
3. 플립플롭의 입력, 출력 및 각 상태에 문자 기호 부여
4. 상태표를 이용해 회로의 상태 여기표 작성
5. 간소화 방법을 이용해 출력 함수와 플립플롭의 입력 함수 유도
6. 순서 논리 회로도 작성

#### 1. 설계 사양으로부터 상태도와 상태표 작성
![image](https://github.com/user-attachments/assets/1581569c-37a8-422c-89bf-29632ebce4c2)

* 그림 3-81은 설계하려는 순서 논리 회로에 대한 상태도다.
* 네 가지 상태에 2진수 00, 01, 10, 11이 할당되었다.
* 일반적으로 방향이 표시된 선들은 '/'로 구분되는 2진수가 2개다.
* /앞의 2진수는 현재 상태 동안의 입력 값이고, / 뒤의 2진수는 현재 상태동안의 출력 값이다.
* 그림에는 출력이 없고 2진수 하나만 있는데, 이는 입력 변수만 있고 출력 변수는 없는 상태에서 상태 변화가 일어남을 의미한다.

* 상태표는 현재 상태와 외부 입력의 변화에 따라 다음 상태의 변화를 정의한 것으로 상태도에서 유도할 수 있다.
* 그림 3-81의 상태도에서 상태표를 유도하기 위해 네 가지 상태를 나타내고 있는 두 플립플롭에는 상태 변수 A와 B를 할당하고, 외부 입력에는 변수 x를 할당한다.
* 표 3-8은 현재 상태 A, B가 외부 입력 x의 변화에 따라 다음 상태 A, B로 변하는 모습을 보여준다.

#### 2. 플립플롭의 수와 종류를 결정하고 3. 각 상태에 문자 기호 부여
* 그림 3-81에는 네 가지 상태가 있으므로 플립플롭이 2개 필요하며, 각 플립플로벵 문자 A와 B를 할당한다.
* 그리고 JK플립플롭을 이용한다.
* 표 3-8의 상태표에서 현재 상태와 다음 상태를 표시할 때 변수 A와 B를 사용했는데, 현재 상태 A=1, B=1은 플립플롭 A의 Q출력, 즉 QA=1이고 플립플롭 B의 Q출력, 즉 QB=1이라는 의미다.
* 그리고 외부 입력이 x=1이면 플립플롭이 다음 상태인 QA=0과 QB=0으로 변한다는 의미이다.

#### 4. 상태표를 이용해 회로의 상태 여기표 작성
![image](https://github.com/user-attachments/assets/223ad876-f752-49e9-82ec-476c74a076f0)

* 표 3-9의 상태 여기표는 현재 상태가 외부 입력과 결합해 다음 상태로 변할 떄 플립플롭의 입력에 인가해야 하는 값을 보여준다.
* 예를 들어 8가지의 상태 변화 중에서 마지막 행인 A=1, B=1에서 A=0, B=0으로 상태 전이가 일어나는 경우를 생각해 보자.
  * 두 JK플립플롭의 현재 상태가 QA=1, QB=1이고, 이 상태가 외부 입력 x=1과 결합하여 다음 상태인 QA=0, QB=0으로 변하고 있다.
  * JK플립플롭의 여기표를 참고하면 QA=1, QB=1에서 QA=0, QB=0이 되려면 두 JK플립플롭에 JA=x, KA=1, JB=x, KB=1이 입력되어야 한다.
  * 나머지 상태 변화도 같은 방법으로 이해할 수 있다.
 
#### 5. 간소화 방법을 이용해 출력 함수와 플립플롭의 입력 함수 유도
![image](https://github.com/user-attachments/assets/d320af56-3310-49ae-b9e0-d9cd5390a052)

* 입력 변수는 A, B, x이고 조합 논리 회로의 출력은 플립플롭의 입력이 된다.
* 간소화된 플립플롭의 입력 함수는 표3-9에 대한 카르노 맵을 그림 3-82와 같이 그려서 구할 수 있다.

#### 6. 순서 논리 회로도 작성
![image](https://github.com/user-attachments/assets/7efd7caa-7ff0-49de-9926-e90ddf689cda)

* 간소화된 입력 함수를 이용해 전체 순서 논리 회로를 구현하면 그림 3-83과 같다.
* 구현된 순서 논리회로는 플립플롭의 현재 출력(QA, QB)의 외부 입력(x)과 함께 조합 논리 회로에 입력되어 출력(JA, KA, JB, KB)을 변화시키면, 이 출력이 바로 플립플롭의 입력이 되므로 플립플롭의 상태가 변함을 알 수 있다.

### 4. 카운터의 설계
* JK플립플롭을 사용해 3비트 동기식 카운터를 순서 논리 회로 방식으로 설계해보자
![image](https://github.com/user-attachments/assets/5b5d932d-0316-402c-b8db-e67e2e023111)

![image](https://github.com/user-attachments/assets/2af0d806-defc-4d77-a745-39920339a728)

![image](https://github.com/user-attachments/assets/5dbe4e3b-fa3f-4321-a765-2e04a5c86e68)

### 5. 레지스터
![image](https://github.com/user-attachments/assets/bba7118a-0123-4412-8300-353349761bc0)

* 레지스터는 기본적으로 데이터 비트를 저장하는 소자
* 대부분의 레지스터에는 D플립플롭이 사용되며 각 D플립플롭에 한 비트씩 저장
* 따라서 n비트 레지스터는 플립플롭 n개로 구성되며, n비트의 2진 정보를 저장할 수 있다.

#### 4비트 레지스터
![image](https://github.com/user-attachments/assets/0f14aa69-5f9b-4fd9-965f-f9cd1ed101a8)

* 공통 클록 신호의 상승 에지에서 입력데이터 (IA, IB, IC, ID)가 D플립플롭에 4개에 동시에 저장되며, 출력(OA, OB, OC, OD)에서는 언제든지 저장된 데이터를 출력할 수 있다.
* (CLR)'=0이면, 클록에 관계없이 언제든지 모든 플립플롭의 출력을 0으로 만들 수 있다.

#### 시프트 레지스터
![image](https://github.com/user-attachments/assets/f252c951-c7de-4701-ab17-c2e269b68dba)

* 클록펄스가 입력될 때마다 클록 펄스의 상승 에지에서 입력 데이터가 한 비트씩 오른쪽으로 시프트하면서 저장(I-> QA, QA->QB, QB->QC, QC->QC)
* 이 과정은 새로운 클록 펄스의 상승 에지마다 반복되므로 네 번째 클록 펄스의 상승 에지에서 처음에 입력된 데이터 비트가 QD에 나타난다.

#### 병렬 로드를 가지는 양방향 시프트 레지스터
![image](https://github.com/user-attachments/assets/42f2d86a-3052-476a-a3b4-e6e1e58786f2)

![image](https://github.com/user-attachments/assets/f8b461d1-97b8-4832-816f-181fc3b3ead8)

## 3.5. 집적 회로
* 집적 회로는 작은 실리콘 칩에 저한, 커패시터, 다이오드, 트랜지스터 등 전자 부품을 여러 공정을 거쳐 내부적으로 상호 연결한 것
* 칩은 실리콘 반도체로 세라믹 또는 플라스틱 기판에 부착하여 외부 핀에 연결한다.

![image](https://github.com/user-attachments/assets/d27c85f6-5ca7-4477-b4a8-0c4e834c0a07)

![image](https://github.com/user-attachments/assets/31796568-849f-4e24-90a4-441deaf4c715)

![image](https://github.com/user-attachments/assets/4dc4c7ce-1606-477d-944c-cd12f13ae2dd)

![image](https://github.com/user-attachments/assets/91e10d5e-2f7b-4669-8c3f-4e175c671974)

![image](https://github.com/user-attachments/assets/7d795aef-855c-4e3b-8b1e-6cbcc7773061)
