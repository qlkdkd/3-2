# 4. 컴퓨터 구성 요소
## 4.1. 프로그램 실행
### 기계어 프로그램
#### 컴퓨터
* 프로그램을 실행하는 기계
* 프로그램은 기계어(machine language)의 모임
* 기계어 명령어를 실행하는 기계

![image](https://github.com/user-attachments/assets/4d710e12-ec06-4fba-8811-e0d8d0c4a276)

#### 기계어
* 명령어는 이진수 코드
* 명령어 종류별로 길이가 다를 수 있다

#### 어셈블리 언어와 어셈블러
* 의미를 쉽게 알 수 있도록 어셈블리 언어로 표현
* 어셈블러는 어셈블리 언어 명령어를 기계어로 번역한다.

![image](https://github.com/user-attachments/assets/97d4495f-2abe-42cc-8045-644598417c37)
* 주소부분: 기계어 명령어가 배치된 주기억장치 주소
* 기계어 코드 부분: 그 주소에 저장되어 있는 기계어 명령어
* 어셈블리 언어 부분: 기계어 명령어에 대한 어셈블리 언어 명령어
* 주소와 기계어 코드는 16진수로 표현되어 있다. 기계어는 2진수 코드로 만들어져 있다.

* 기계어를 대신하는 언어를 어셈블리어라고 하고, 어셈블리어로 작성한 프로그램을 어셈블리어 프로그램이라고 한다. 어셈블리어 프로그램을 기계어 프로그램으로 번역하는 프로그램을 어셈블러라고 한다.

### AVR 기계어 프로그램
#### AVR 기계어 코드는 길이가 같다.
* AVR 프로세서: 아두이노에서 활용
#### 기계어 프로그램은 프로세서 종류마다 다르다.

![image](https://github.com/user-attachments/assets/ef88affb-63df-4fa5-bced-cd5c24a98801)

### 프로그램 내장형 컴퓨터
#### 프로그램 내장형 컴퓨터
* 폰 노이만형 컴퓨터
* 프로그램과 데이터를 주기억장치에 저장한다.
* 명령어를 한 개씩 중앙처리장치로 가져와 실행한다.

#### 기억장치 구조
* 일반 구조: 한개의 기억 장치에 프로그램과 데이터를 함께 저장한다.
* 하버드 구조: 프로그램과 데이터를 별도의 기억 장치에 저장한다.

![image](https://github.com/user-attachments/assets/4d676181-1b3c-411e-87b1-f540b779b97b)

### 명령어 사이클
* 중앙처리장치는 컴퓨터에 전원을 인가한 후 그림 3-3과 같이 두 가지 단계를 무한히 반복함으로써 프로그램을 실행한다.
* 이 과정을 **명령어 사이클(instruction cycle)** 또는 머신 사이클이라고 한다.
* 첫 번째를 명령어 **인출 단계**, 두 번째를 명령어 **실행 단계**라고 한다.

* 인출단계: 기억장치에서 명령어를 중앙처리장치로 가져온다.
* 실행단계: 중앙처리장치에서 명령어를 해독하여 실행한다.

![image](https://github.com/user-attachments/assets/aa3ad6fd-1b02-4931-ae11-b1d9dfbce155)

## 4.2. 컴퓨터 구성 요소
![image](https://github.com/user-attachments/assets/a06ea4bc-94c0-4766-8923-1a05f60c23d7)

### 중앙처리장치
#### 인출단계: 기억 장치에서 명령어를 하나씩 가져온다.
* 구성 요소
  * PC(Program Counter)
  * IR(Instruction Register)
 
* 동작
  * IR<- Mem\[PC\]
  * PC<- PC+\[명령어의 길이\]
 
#### 실행단계: IR의 명령어를 해석하여 실행한다.
* 구성요소
  * 제어 장치(Control Unit)
  * 내부 레지스터
  * 연산기(산술/논리 연산)
 
* 동작
  * 명령어마다 하는 일이 다르다
 
### 중앙처리장치 구조
* PC: 다음에 실행할 명령어가 들어있는 기억장소 주소를 저장한다.
* IR: 인출단계에서 프로그램 카운터가 지정한 기억 장소에서 인출한 명령어를 저장한다.
* 제어장치: 명령어 레지스터에 저장된 명령어를 해독하고, 필요한 제어신호를 생성한다.
* 내부레지스터: 명령어를 처리하기 위하여 중앙처리장치에 데이터를 저장하는 임시 기억장치가 필요한데, 이것이 내부 레지스터이다.
* 연산기: 중앙처리장치에서 데이터를 처리하는 기능을 담당한다.

![image](https://github.com/user-attachments/assets/d455965e-a878-4a47-b493-934bb06781f1)

### 주기억장치
![image](https://github.com/user-attachments/assets/51ea5e88-7b37-42b2-b0ee-52b3dedc57da)

* 주기억장치는 프로그램과 데이터 저장
* 기억장치는 주소를 지정하여 데이터를 액세스하는 거대한 1차원 배열로 생각할 수 있다.
* 그림 3-6과 같이 n비트 주소선, k비트의 데이터선, 그리고 읽기와 쓰기 제어선으로 외부와 연결된다.
* 각 선의 용도
  * 주소선: 기억장치에 대한 입력신호로 작용한다. 기억장치에 포함된 여러 개의 기억장소 중 하나를 지정한다. n비트의 주소선으로 2^n개의 기억장소 중 하나를 지정할 수 있다.
  * 데이터선: 기억장치에 대한 입력과 출력신호로 작용한다. 기억장치와 외부 다른 장치(예를 들면 중앙처리장치)간에 데이터를 주고받는 경로이다. 데이터선이 k비트라는 것은 한 개의 기억장소에 k비트 데이터를 저장한다는 의미이다.
  * 읽기/쓰기 제어선: 제어선은 기억장치에 대한 입력신호이다. 기억장치의 제어선은 읽기와 쓰기 신호가 있다. 만일 읽기 제어신호가 인가되면, 주소선으로 지정된 기억장소에 저장된 데이터가 읽혀 나온다. 만일 쓰기 제어신호가 인가되면, 주소선으로 지정된 기억장소에 데이터선으로 인가된 데이터가 저장된다.
 
* 중앙처리장치는 다음과 같은 두 가지 방법으로 기억장치를 액세스한다. 일반적으로 적재와 저장을 동시에 지칭할 때 액세스라고 표현한다.
  * 적재(load): 기억장치 한 장소에서 데이터를 읽어 중앙처리장치의 레지스터로 가져온다. 주소선에 기억장치 주소가 인가되고, 기억장치 읽기(memory write) 제어신호가 인가된다.
  * 저장(store): 중앙처리장치의 레지스터에서 기억장치 한 장소에 데이터를 저장한다. 주소선에 기억장치 주소가 인가되고, 데이터선에 저장될 데이터 값이 실리고, 기억장치 쓰기(memory write)제어신호가 인가된다.
 
![image](https://github.com/user-attachments/assets/614dfd1f-bb6f-46f0-8be2-3d464ff2adb8)

### 입출력장치
#### 기능
* 프로그램과 데이터를 공급한다.
* 컴퓨터가 처리한 데이터를 출력한다.

#### 특징
* 종류가 다양하고, 기계 동작을 포함한다.
* 중앙처리장치와 주기억장치에 비하여 동작 속도가 느리다.

#### 예
* 입력 장치: 키보드, 마우스, 마이크, 카메라, 터치 스크린, 스캐너
* 출력 장치: 모니터, 프린터, 플로터, 스피커
* 입출력장치: 보조기억장치(디스크, usb메모리 등), 네트워크 어댑터 등

### 입출력장치 구조
#### 구조
* 인터페이스: 입출력장치를 컴퓨터 시스템과 연결한다. 입출력장치와 중앙처리장치의 차이점인 동작 방식, 데이터 전송 속도, 데이터 형식을 조절한다.
* 신호변환기: 전기 신호를 입출력장치 고유의 기계 동작으로 변환하거나, 그 반대의 변환을 수행한다.
* 기계장치: 실제 입출력장치 고유 기능을 수행한다.

#### 입출력 주소 혹은 입출력 포트
* 입출력장치를 구별하기 위하여 장치마다 할당된 고유 번호
* 컴퓨터에 연결되어 있는 입출력장치마다 서로 다른 주소 영역을 할당한다.

### AVR 마이크로 제어기
#### 마이크로제어기
* 하나의 칩에 중앙처리장치, 기억장치, 주변장치를 포함한 반도체소자
* 소형 임베디드 시스템의 제어장치로 쓰임

![image](https://github.com/user-attachments/assets/bb322415-78b7-4b7b-bacf-edf3c5a03e92)

> * 기억 장치가 프로그램 기억장치와 데이터 기억장치로 나뉘어져 있는 하버드 구조이다.
> * 프로그램은 플래시 프로그램 기억장치에 저장된다. 이 부분은 전기가 끊기더라도 저장된 내용을 보존한다. 프로그램 기억장치의 용량은 64K\*16비트이다. 바이트 단위로 128K바이트이다.
> * 프로그램이 처리하는 데이터를 저장하는 별도의 데이터 기억장치(SRAM, Data Memory)를 포함하고 있다. 이 부분은 전기가 끊어지면 내용이 지워진다. 용량은 4K\*8비트이다.
> * 프로그램 카운터 크기는 16비트이고, 프로그램 기억장치로 주소를 제공한다.
> * 대부분의 명령어는 크기가 16비트이고, 기억장치 주소를 포함하는 명령어만 길이가 32비트이다. 인출된 명령어는 크기가 16비트인 명령어 레지스터(IR)에 저장된다.
> * 명령어 레지스터는 제어장치(Control Unit)로 명령어를 전달한다. 제어장치는 명령어를 해독하여 프로그램 실행을 제어하는데 필요로 하는 모든 제어신호를 생성한다.
> * 8비트 상태 레지스터(SR, Status Register)를 포함하고 있다.
> * 32개의 8비트 범용 레지스터(GPR, General Purpose Register)를 포함하고 있다. 이름은  R0, R1, ..., R31이다. 이것들은 프로그램이 처리하는 데이터를 임시로 저장한다.
> * 칩 안에 여러가지 주변 장치를 포함하고 있다. 내부 발진기, 인터럽트 제어기, 직렬통신 제어기, 타이머, 아날로그 비교기, EEPROM 등이 주변장치의 예이다. 이것들은 모두 입출력장치에 해당한다.

## 4.3. 시스템 버스
### 시스템 버스 구성
* 주소 버스: 기억 장치 또는 입출력장치의 주소를 지정한다. 기억장치 용량과 관련이 있다.
* 데이터 버스: 데이터를 전달하는 경로이고, 일반적으로 8의 배수이다. 데이터버스의 비트 수 = 레지스터의 크기 = 단어 크기(word size)
* 제어 버스: 주소 버스와 데이터 버스를 제외한 나머지 신호. 각각 고유한 기능을 갖는다.

![image](https://github.com/user-attachments/assets/aeba54c4-4731-4b2c-9edf-1dc3b203a963)

### 제어 신호 종류
* 기억 장치 제어(RAM)
  * 기억장치 읽기
  * 기억장치 쓰기
 
* 입출력장치 제어
  * 입출력 읽기
  * 입출력 쓰기
  * 인터럽트 요청
  * 인터럽트 확인
  * 버스 요청
  * 버스 승인
 
* 기타
  * 시스템 클럭
  * 리셋
  * 전력선
 
### 버스 계층
* 버스 계층
  * 버스 경쟁 완화
  * 시스템 버스: 지역 버스, 고속 버스
  * 입출력 버스: 확장 버스, 저속 버스, 장치 버스
![image](https://github.com/user-attachments/assets/839abba0-b828-439b-b875-b79083379777)

* 상대적으로 속도가 빠른 중앙처리장치와 기억장치를 시스템 버스에 연결하고, 입출력장치를 입출력 버스에 연결한다. 브리지는 두 개의 버스를 서로 연결하는 중재장치이다.

## 4.4 명령어
### 명령어 구성 요소
* 명령어
  * 하드웨어와 소프트웨어가 만나는 부분
  * 컴퓨터가 수행할 일을 2진수 코드로 표현한 것
* 구성 요소
  * 동작 코드(opcode)
  * 동작의 대상(operand)
* 명령어 형식
  * 명령어에 포함된 정보를 2진수에 배치한 형태
  * 전체 길이, 필드 구성과 의미, 각 필드의 비트 수
 
![image](https://github.com/user-attachments/assets/37327d3a-440b-4e20-9fe8-98bb6ec11203)

### 명령어 종류
#### 동작 코드에 따른 명령어의 종류
* 데이터 전달 명령어: 내부 레지스터, 주기억장치, 입출력 장치 간 데이터 전달(복사)
* 데이터 처리 명령어: 내부 레지스터 또는 주기억장치의 데이터를 연산
* 프로그램 제어 명령어: 프로그램 실행 순서 변경

![image](https://github.com/user-attachments/assets/84ebf81a-8462-449d-afdc-e635d206b77c)

### 데이터 전달 명령어
* 데이터 전달 명령어는 컴퓨터 구성 요소의 한 장소엣 다른 장소로 데이터를 복사함
* 데이터 전달 명령어 종류
  * 적재(load): 기억장치 한 장소에서 레지스로 데이터를 가져온다(Register <-Mem\[address\])
  * 저장(store): 레지스터에서 기억장치의 한 장소로 데이터를 저장한다(Mem\[address\]<-Register)
  * 이동(move): 소스 오퍼랜드에서 목적지 오퍼랜드로 데이터를 이동한다. 각 오퍼랜드는 기억장치 한 장소 또는 레지스터일 수 있다. ({Register, Mem\[address\]},_{Register, Mem\[address\]})
  * 입력(input): 입출력 포트에서 레지스터로 데이터를 입력한다.(Register->I/O port\[address\])
  * 출력(output): 레지스터에서 입출력 포트로 데이터를 출력한다.(I/O port\[address\]<-Register)
 
![image](https://github.com/user-attachments/assets/77f59fbc-ffdd-47ef-8f94-0a930b7a49ed)

### 데이터 처리 명령어
* 단항 연산 명령어: 한개의 항으로 계산을 수행하는 명령어
  * 목적지=op소스
  * 음수, 부호변경
  * Not, shift
  * 증가, 감소
 
* 이항 연산 명령어: 두 개의 항으로 계산을 하는 명령어
  * 목적지=소스1 op 소스2
  * 소스 오퍼랜드 한 개 생략 가능: 목적지=목적지 op 소스
  * 사칙연산
  * 논리연산
 
![image](https://github.com/user-attachments/assets/47fe8811-d430-4024-b0ec-07efa07efbbb)

### 프로그램 제어 명령어
* 프로그램 실행 순서 변경: 궁극적으로 PC값 변경
* 프로그램 제어 명령어 종류
  * 무조건 분기: 프로그램 카운터 값을 분기 목적지 주소로 변경하여 항상 분기 목적지로 분기함(PC<-\[분기 주소\])
  * 조건 분기: 특정한 조건을 검사하여 분기 여부를 결정함(if(조건)PC<-\[분기 주소\])
  * 서브루틴 호출: 프로그래밍 언어의 함수 호출에 대응하는 명령어로써, 서브루틴으로 이동하는라는 동작코드와 서브루틴의 시작 주소를 분기 목적지 주소로 포함한다.(PC저장/PC<-\[서브루틴 시작 주소\])
  * 서브루틴 복귀: 서브루틴 또는 함수를 실행하고 다서 그 서브루틴을 호출한 곳으로 돌아갈 때 저장해 두었던 주소로 복귀한다(PC<-\[저장된 주소\])
 
![image](https://github.com/user-attachments/assets/4e182a26-f8a9-4368-9a59-27947bb40a68)

### 오퍼랜드
* 오퍼랜드(opereand, 피연산자): 명령어가 처리하려는 동작의 대상
* 유효 데이터
  * 중앙처리장치가 실제로 처리하는 데이터
  * 크기가 정해진 2진수 형태(예: 8비트, 16비트, 32비트)
* 오퍼랜드 유형
  * 즉치 데이터: 명령어가 유효 데이터를 포함한다.
  * 레지스터 이름: 레지스터의 값이 유효 데이터
  * 기억장치 주소: 기억장치 해당 주소의 값이 유효 데이터
  * 입출력 포트: 입출력 포트의 값이 유효 데이터
 
![image](https://github.com/user-attachments/assets/b9d3c8b8-16bf-4554-a89a-7a30f5223c19)

### 유효 데이터 해석
* 해석 방법
  * 부호 없는 수
  * 정수
  * 실수
  * 문자 코드
 
* 명령어와 오퍼랜드의 관계
  * 명령어에 따라 유효 데이터를 해석하는 방법이 다르다.
  * 길이, 해석 방법이 다르면 명령어의 동작 코드도 달라야 한다.
