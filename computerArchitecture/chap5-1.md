# 5. 중앙처리장치
## 5.1. 중앙처리장치 구조
#### 중앙처리장치 기능 요약
* 프로그램 실행: 프로그램 = sequence of instructions
* 인출 단계: IR<- Mem(PC), PC<- PC+명령어(단어) 크기
* 실행 단계: 제어장치에서 명령어 해석하고, 처리장치에서 실행

### 중앙처리장치 구조
![image](https://github.com/user-attachments/assets/67220816-535b-4f7f-966a-03dc07c12da7)
* 중앙처리장치는 명령어 사이클을 반복하여 프로그램을 진행한다.
* 명령어 사이클은 인출단계와 실행단계로 구성되어 있다.
* 인출 단계는 주기억장치에 저장된 명령어를 중앙처리장치로 가져온다.
* 중앙처리장치는 프로그램 카운터(PC)와 명령어 레지스터(IR)를 필요로 한다.
* 실행 단계는 명령어를 해석하고 실행한다.

### 제어장치
#### 제어장치 기능
* 순서 제어: 현재 실행하고 있는 명령어를 구별한다.
* 동작 제어: 각 명령어를 실행한다.

#### 제어장치 입출력
* 입력
  * 명령어 레지스터(IR): 현재 실행하고 있는 명령어를 구별한다.
  * 상태 레지스터(SR): 조건 분기 처리를 위한 조건을 판단한다.
 
* 출력
  * 타이밍 신호: 명령어 사이클을 진행하기 위한 타이밍 신호를 생성한다.
  * 제어 신호: 컴퓨터의 구성 요소를 구동하는 제어 신호를 생성한다.
 
### 처리장치
* 레지스터
  * 중앙처리장치 내부 기억장치: 주소와 데이터 임시저장
  * 제어용 레지스터: PC, IR, MAR, MBR
  * 명령어 실행용 레지스터
    * 데이터 레지스터(DR), 주소 레지스터(AR), 범용 레지스터(GPR)
   
* 연산기
  * 데이터 처리 담당
  * 제어신호는 연산기의 동작 결정
  * 연산 후 상태를 상태 레지스터에 저장
 
![image](https://github.com/user-attachments/assets/37e6cf21-c93c-47df-90be-62394d648c40)

### 상태 레지스터 사용 예
```assembly
CMP X, Y //compare X and Y
BRG lable1 //branch to lable1 if greater than 0
INC X //increment x
lable1...  //brach to here
```
1. CMP X, Y: X와 Y를 비교한다. 이 명령어는 연산기에서 X-Y를 하며, 그 결과를 레지스터에 기록하지 않는다. 다만 연산 결과가 0인지, 0보다 큰지, 아니면 작은지에 대한 상태 정보를 상태 레지스터에 기록한다.(비교 결과를 상태 레지스터에 저장)
2. BRG lable1: 조건분기 명령어다. 만일 이전 명령어의 결과가 0보다 크다고 상태 레지스터에 저장되어 있다면, lable1로 지정된 주소로 이동하라는 의미이다.(상태 레지스터를 참조하여 분기 여부 결정)
3. INC X: X의 값을 증가시킨다. 만일 2에서 조건을 만족하지 않으면, 여기로 온다.
4. lable1: 여기에 배치된 명령어의 주소를 의미하며, 2에서 지정한 분기 목적지 주소이다.

## 5.2. 레지스터
### 제어용 레지스터
* 프로세서가 프로그램을 진행하는 데 사용하는 레지스터
* 프로그램 카운터(PC): 다음에 실행할 명령어가 저장된 기억장치 주소
* 명령어 레지스터(IR): 현재 실행 중인 명령어
* 기억장치 주소 레지스터(MAR, Memory Address Register): 기억장치 주소 저장, 주소 버스에 연결
* 기억장치 버퍼 레지스터(MBR, Memory Buffer Register): 기억장치 데이터 중계, 데이터 버스에 연결

### 기억장치 액세스
* 데이터 읽기(명령어 인출단계)
  1. MAR<- 주소 레지스터 // 주소 레지스터의 값을 MAR로 적재한다.
  2. MBR<- Mem[MAR] // 기억장치를 읽어 데이터를 MBR에 저장한다.
  3. 데이터 레지스터<- MBR // MBR의 값을 목적지 레지스터에 저장한다.
 
* 데이터 쓰기 
  1. MAR<- 주소 레지스터 // 주소 레지스터의 값을 MAR로 적재한다.
  2. MBR<- 데이터 레지스터 // 기록할 데이터를 MBR에 저장한다.
  3. Mem[MAR]<- MBR // 기억장치에 MBR의 값을 기록한다.
 
### 상태 레지스터
* 상태 레지스터: 플래그의 모음
  * 플래그(flag): 상태 레지스터는 각 비트 별로 의미가 있으며, 각 비트를 깃발이란 의미로 플래그(flag)라고 한다.
* 플래그

![image](https://github.com/user-attachments/assets/8c94864f-8b05-4ff9-b97e-1758ad7e141d)

  * 조건 플래그: 연산 결과 반영
    * 부호 플래그(S, sign flag): 최근에 수행한 산술 연산 결과의 부호 비트(sign bit)를 저장한다. 부호 비트는 2진수의 MSB(Most Significant Bit)이다. 이 값이 1이면 연산 결과가 음수이고, 0이면 연산 결과가 양수이다.
    * 제로 플래그(Z, zero flag): 최근에 수행한 산술 연산 결과가 0일때 1로 세트되낟. 연산 결과가 0이면 1, 0이 아닌 값이면 0으로 설정된다.
    * 자리올림수(C, carry flag): 최근에 수행한 산술 연산이 2진수 덧셈이고, 덧셈에서 자리올림수가 발생할 때 세트된다.
    * 패리티 비트(P, parity bit): 최근에 수행한 연산 결과에 대한 짝수 또는 홀수 패리티를 정한다. 패리티는 2진수에 포함된 1의 수를 세어 패리티 비트와 합하여 전체 1의 수를 짝수 또는 홀수로 맞추느 것이다. 일반적으로 짝수 패리티로 맞춘다.
    * 오버플로우(O, overflow flag): 최근에 수행한 정수 산술 연산을 수행한 후 결과에 오버플로우가 발생하였는지 표시한다. 오버플로우는 정수 연산 결과가 데이터 비트 수로 포현할 수 있는 정수 표현 범위를 초과한 것이다.
   
  * 제어 플래그: 중앙처리장치 동작 제어
    * 인터럽트(IE, interrupt enable flag): 이 비트가 1로 세트되어 있을 때 중앙처리장치는 외부 인터럽트 요청을 인식할 수 있다. 명령어 집합은 이 비트를 세트하고 리셋하는 명령어를 포함하고 있다. 프로그래머는 이 명령어를 사용하여 인터럽트 가능 플래그를 1 또는 0으로 설정할 수 있다.
    * 운영체제 모드 플래그(SV, supervisor mode flag): 중앙처리장치가 운영체제 모드(kernel mode 또는 supervisor mode)와 사용자 모드(user mode) 중에서 어느 모드로 프로그램을 실행 중인지 나타낸다.
   
### 명령어 실행용 레지스터
* 데이터 레지스터
  * 중앙처리장치가 처리하는 데이터 임시 저장
  * 누산기(accumulator)
 
* 주소 레지스터
  * 기억장치 주소 저장
  * 중앙처리장치는 기억 장치를 다양한 방법으로 액세스한다.
  * 스택 포인터, 베이스 레지스터, 인덱스 레지스터
 
* 범용 레지스터
  * 데이터 레지스터+주소 레지스터
  * 통상 8개\~ 32개
 
### 주소 레지스터
* 포인터(pointer): 주소 레지스터와 같은 의미. 기억장치 주소를 의미
* 레지스터에 기억장치 주소를 저장하면, 명령어 길이가 짧아진다.

![image](https://github.com/user-attachments/assets/86b743fb-e35c-454e-9dd8-38f807220701)

### 스택 포인터
* 스택
  * Last In First Out: 데이터를 쌓아 두었다가 하나씩 꺼내서 사용
  * 한 곳에서 액세스: stack top<- stack pointer
 
* 시스템 스택
  * 프로세서가 주기억장치의 일부를 스택 영역으로 활용
  * 함수 호출 시 리턴 주소 저장, 지역 변수 저장, 파라미터 전달
 
* SP(Stack Pointer)
  * 시스템 스택의 탑(top)을 가리키는 레지스터
 
### 스택 구조
* SP가 가리키는 곳까지 데이터가 채워진 부분
* 데이터를 저장하면, SP감소/ 데이터를 제거하면 SP증가

![image](https://github.com/user-attachments/assets/70fbeba2-b260-4991-804b-45a3823747ec)

* a. 기억장치 임의의 영역을 스택으로 사용하는 예
* **b. 기억장치 주소의 마지막 부분부터 주소가 감소하는 방향으로 스택을 배정한 예**

### 스택 동작
* 스택의 데이터 크기=레지스터 크기=단어 크기
* PUSH: 스택에 데이터를 추가하는 동작. 스택에 저장할 오퍼랜드 지정해야 함
* POP: 스택에 데이터를 제거하는 동작. 스택에서 제거한 데이터를 저장할 오퍼랜드 지정해야 함
* 중앙처리장치는 푸시와 팝 동작을 수행하는 기계어 명령어를 갖고 있으며, 이 명령어에 해당하는 기호는 대부분 푸시와 팝이다.
* 일반적으로 스택에 저장되는 데이터 크기는 레지스터 크기, 데이터 버스 폭과 같다.
* 즉, 스택은 단어(word)단위로 데이터를 액세스한다.
* 만일 기억장치가 8비트 단위로 구성되어 있고 레지스터의 크기가 16비트이면, 두 개의 기억장소에 한 개의 단어를 저장한다.
![image](https://github.com/user-attachments/assets/78fc2815-cf84-461f-a103-430eb408ddf1)

* 범용 레지스터 R0과 R1의 크기는 16비트이다.
* 기억장치는 바이트 단위로 주소를 지정하며, 스택은 16비트 단위로 데이터를 액세스한다.
* 기억장치 주소는 16비트이다. 따라서 스택 포인터 크기도 16비트이다.
* 현재 스택 포인터의 값은 F006h이고, 스택 포인터가 가리키는 장소까지 데이터가 저장되어 있다.

> * PUSH 오퍼랜드:
>   * SP<- SP[단어 크기]
>   * Mem[SP]<- operand

* 초기 상태에서 PUSH R0 명령어를 실행한 상태.
* 스택 포인터 값이 F004h로 감소하였고, 기억 장치 F004번지에 레지스터 R0의 값 1004h를 저장

> * POP operand
>   * operand<-Mem[SP]
>   * SP<- SP+[단어 크기]

* POP R1명령어를 실행한 상태
* 레지스터 R1값을 1004h로 변경하고, 스택 포인터 값이 F006h로 증가
* 스택의 F004h번지에 이전 값 1004h가 남아 있으나, 이 값은 이제 의미가 없는 쓰레기 값
* 이후 다른 PUSH명령어를 실행하면 이 값을 다른 값으로 덮어 씀

### 스택 구현
![image](https://github.com/user-attachments/assets/081baddc-4d77-4a7b-b243-6841d7495642)

### 베이스 레지스터
* 베이스 레지스터: 스택의 기준점
* 베이스 레지스터 활용 예제

![image](https://github.com/user-attachments/assets/a8dc715e-b7e0-4f08-9579-7b7e3fbdc460)

### 베이스 레지스터 활용
![image](https://github.com/user-attachments/assets/749c4f10-c2ba-47a0-b20c-b6b30db1c000)

* a. 함수 호출 전: 이 함수를 호출하기 전에 스택 포인터(SP)와 베이스 레지스터(BR)은 스택의 어딘가를 가리키고 있다.
* b. 파라미터 전달: 함수를 호출하는 문장을 실행하면서, 파라미터 param3, param2, param1의 순서로 스택에 푸시한다. 이 동작에 따라 스택 포인터(SP)값이 변경된다.
* c. 복귀 주소 저장: 실제로 함수를 호출하는 명령어를 실행하면서, 복귀 주소(return address)를 스택에 저장한다. 프로그램 카운터는 이 함수의 시작 위치로 설정된다.
* d. 이전 BR 저장: 이전 베이스 레지스터(BR) 값을 잃으버리지 않도록, 스택에 베이스 레지스터(BR)값을 푸시한다.
* e. 새로운 BR 설정: 베이스 레지스터(BR)의 값을 현재 스택 포인터(SP)값으로 설정한다. 이 동작을 수행하고 나면, 베이스 레지스터(BR)는 스택의 새로운 기준점을 가리킨다.
* f. 지역 변수 할당: 스택에 지역변수 local1과 local2를 위한 공간을 만들고 그 크기만큼 스택 포인터(SP)를 감소시킨다.

![image](https://github.com/user-attachments/assets/c0eb49c1-ff3b-4c83-a437-14cfb0169454)

* 함수를 호출하기 전 SP=F180h, BR=F188h이다.
* 파라미터 전달: 함수를 호출하면, 파라미터 4, 7, 10을 역순으로 스택에 푸시한다.
* 복귀 주소 저장: 함수에서 복귀할 주소 0420h를 스택에 푸시한다.
* BR 재설정: 현재의 SP값을 BR에 저장한다.
* 지역 변수 할당: 지역 변수 2개를 스택에 할당한다. SP값은 F179h로 설정된다.

### 인덱스 레지스터
* 연속적으로 저장되어 있는 데이터(배열)의 액세스
* 자동 인덱싱(automatic indexing)
 * R0<- R0+Mem(IX), IX<- IX+1

* 예: int array[5]={0, 1, 2, 3, 4}; //1000h번지부터 할당
![image](https://github.com/user-attachments/assets/9c76ebee-6e84-49b0-b077-8998da3df97a)

* a에서 인덱스 레지스터 IX의 초기값은 배열 array의 시작 주소인 1000h로 설정되어 있다. 배열 원소를 차례대로 읽어 레지스터 R1에 저장하는 레지스터 전송문은 다음과 같다.
```assembly
R0<- R0+Mem(IX), IX<- IX+1
```

* b에서 레지스터 R0는 배열의 시작 주소 1000h를 저장하고 있고 인덱스 레지스터 IX는 0으로 초기화되어 있다. 배열을 사용하는 도중에 R0값은 변경되지 않는다. 배열 원소를 차례대로 읽어 레지스터 R1에 저장하는 레지스터 전송문은 다음과 같다.

```assembly
R1<- Mem[IX+R0], IX<- IX+2
```

### 프로세서 레지스터
![image](https://github.com/user-attachments/assets/f233bd99-9de9-4118-88cb-27c89102e3b9)
