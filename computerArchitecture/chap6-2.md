## 6.4. 시프트 연산
* 시프트 연산: 왼쪽이나 오른쪽으로 한 비트씩 자리 이동

### 논리시프트
![image](https://github.com/user-attachments/assets/46db2729-f3b4-4939-bfdd-d3cd67abdf68)

* 논리시프트 연산은 오퍼랜드를 부호 없는 수로 취급
  * 왼쪽 논리시프트: 각 비트를 한 자리씩 왼쪽으로 이동한다. 최하위비트는 0으로 채워지고, 일반적으로 레지스터에서 제거되는 최상위비트는 상태 레지스터의 자리올림수 플래그(carry flag, C)에 저장된다.
  * 오른쪽 논리시프트: 각 비트를 한 자리씩 오른쪽으로 이동한다. 최상위비트는 0으로 채워지고, 일반적으로 레지스터에서 제거되는 최하위 비트는 상태 레지스터의 자리올림수 플래그에 저장된다.
 
### 산술 시프트
![image](https://github.com/user-attachments/assets/0f82b01a-0ad1-4e10-ad28-d4db9a8e37eb)

* 산술시프트는 2진수에 대하여 방향에 따라 곱하기 2 또는 나누기 2를 계산한 효과가 있도록 만든 시프트 연산이다.
  * 왼쪽 산술시프트: 부호 비트는 그대로 남고, 나머지 비트들이 한 자리씩 왼쪽으로 이동한다. b6가 제거되고 LSB에 0이 채워진다.
  * 오른쪽 산술시프트: 부호 비트는 그대로 남고, 나머지 비트들이 한 자리씩 오른쪽으로 이동한다. b6자리에 부호 비트가 밀려 들어가고, LSB는 제거된다.
```
ASL R1// R1<- R1*2, 왼쪽에 0을 채움
ASR R1// R1<-R1/2, 부호 비트를 채움
```

### 회전
![image](https://github.com/user-attachments/assets/6519afff-c468-4c66-989b-ec73b7244868)

* 회전(rotation)연산은 시프트와 다르게 밀려 없어지는 비트가 반대 방향의 끝에 채워지는 연산이다.회전을 구현하는 회로에 따라 회전하는 비트를 자리올림수에 저장할 수도 있다.

### 멀티플렉서 시프트 회로
![image](https://github.com/user-attachments/assets/bfaf39cf-f875-4918-b4db-21a36bcf6ef0)

* 조합논리회로로 시프트 연산을 구현할 수 있다. 예를 들면, 위 그림은 4\*1 회전 멀티플렉서로 구현한 4비트 시프트 회로이다. 왼쪽의 제어신호는 시프트 연산의 종류를 결정한다. 제어신호 값에 따라 논리 시프트와 산술 시프트를 수행할 수 있다.

## 6.5. 산술 연산
### 단항 연산
* 2의 보수화(부호 변경)
* 증가
* 감소
![image](https://github.com/user-attachments/assets/4348220d-9a82-4706-a98c-c00722cf4792)

### 덧셈과 뺄셈
* 정수를 2의 보수로 표현하기 때문에, 덧셈과 뺄셈 연산은 데이터가 부호 없는 수인지 정수인지 고려할 필요가 없다. 데이터를 부호 없는 수로 취급하여 계산한 후, 결과값을 부호 없는 수로 해석하거나 정수로 해석해도 올바른 결과를 얻을 수 있다.

![image](https://github.com/user-attachments/assets/8a6471df-6d6e-4129-8c43-29826839f59a)

### 오버플로우
* 연산결과가 수의 표현 범위를 초과하는 현상
* $Overflow=C_n\bigoplus C_{n-1}$

![image](https://github.com/user-attachments/assets/ebea04e1-c820-4c03-918e-87330c06fdc9)

### 곱셈
* n비트 곱셈
  * a\*b=곱(product, 2n비트)
  * a: 피승수, b: 승수

![image](https://github.com/user-attachments/assets/484b1b88-a95b-4fd7-937c-f47d787027ba)

![image](https://github.com/user-attachments/assets/9ed0383b-cd4e-4bf2-a664-8a63ab7f7435)
* 곱셈 회로
  * 레지스터 A는 병렬 가산기의 입력과 출력으로 사용하며, 초기값은 0이다.
  * 병렬 가산기는 A+M을 계산하여 합을 레지스터 A에 저장하고 자리올림수를 C에 저장한다. C의 초기값은 0이다.
  * CAQ는 직렬로 연결되어 있고, 제어장치의 shift right 제어신호는 CAQ 전체를 오른쪽으로 시프트한다.
  * 제어장치는 레지스터 Q의 최하위 비트인 Q0을 입력으로 받고, 병렬 가산기에서 덧셈을 수행할지 결정하는 제어신호 add를 생성한다.
  * 제어장치는 카운터 P를 갖고 있다. P의 초기값은 레지스터 비트 수 n이다. 한 비트를 처리할 때마다 P값은 감소되고, P값이 0이면 곱셈이 끝난다.
 
* 곱셈 알고리즘
  * 초기 상태: 시작 신호에 따라 레지스터를 초기화한다. C와 A를 0으로 초기화하고, M에 피승수를 저장하고, Q에 승수를 저장하고, 카운터 P를 비트 수 n으로 설정한다.
  * 부분 곱 계산: 만일 Q0 값이 1이면, 제어 장치는 제어신호 add를 1로 만든다. 이때 CA<-A+M을 수행한다. 만일 Q0값이 0이면 덧셈을 수행하지 않는다.
  * 오른쪽 시프트: CAQ레지스터를 오른쪽으로 한 비트 시프트하고, 카운터 P값을 감소시킨다.
  * 종료 판단: 만일 P의 값이 0이 아니라면, 부분 곱 계싼 단계로 이동하여 다음 비트를 처리한다. 만일 P의 값이 0이면 곱 계산이 끝난 것이고, 2n비트의 곱은 레지스터 AQ에 저장되어 있다.
 
### 나눗셈
* 2n비트/n비트 나눗셈=n비트 몫...n비트 나머지
![image](https://github.com/user-attachments/assets/7ef96cf3-a3a7-4f88-a146-bf7ecfa9d066)

![image](https://github.com/user-attachments/assets/1810be71-0325-4a5a-b8eb-8064771f254b)
* 나눗셈 회로
  * 초기에 피젯수를 레지스터 AQ에 저장하고 젯수를 레지스터 M에 저장한다.
  * 레지스터 A는 레지스터 M에 저장되어 있는 젯수와 크기를 비교하는 데 사용된다.
  * 레지스터 A의 부분 나머지가 레지스터 M의 젯수보다 큰지 검사하기 위하여, 별도의 비교기를 사용하지 않고, 일단 레지스터 A에서 레지스터 M을 뺀다. A-M을 계산하는 대신에 A+M'+1을 계산한다. 이 때 발생하는 캐리를 C에 저장한다. 만일 뺄셈 결과인 자리올림수 플래그 C의 값이 1이면, A>=M이다. 만일 자리올림수 플래그 C의 값이 0이면 A<M이다.
  * CAQ는 직렬로 연결되어 있고, 제어장치의 왼쪽 시프트 제어 신호는 CAQ를 왼쪽으로 시프트한다.
  * 제어장치는 레지스터 A와 레지스터 M의 비교 결과에 따라, 현재 계산하고 있는 비트의 몫으로 레지스터 Q의 최하위 비트인 C를 0 또는 1로 설정한다.
  * 제어장치는 카운터 P를 갖고 있다. P의 초기값은 레지스터 비트 수 n이다. 한 비트를 처리할 때마다 P값은 감소되며, P값이 0이면 계산이 끝난다.
 
* 나눗셈 알고리즘
  * 초기 상태: 시작 신호에 의하여 레지스터들을 초기화한다. C를 0으로 초기화하고, M을 젯수에 저장하고, AQ에 피젯수를 지정하고, 카운터 P를 비트 수 n으로 설정한다.
  * 왼쪽 시프트: CAQ를 왼쪽으로 한 비트 시프트한다.
  * 크기 비교: A와 M의 크기를 비교하기 위하여 일단 A-M(A+M'+1)을 계산한다. 뺄셈 후, C=1이면, A>=M이고, C=0이면 A<M이다.
  * 몫 결정: 만일 C=1이면, 현재 처리하고 있는 비트의 몫으로 A+M'+1을 1로 설정한다. 만일 C=0이면 A+M'+1을 그대로 유지한다. 이때는 CA<-A+M을 수행하여 부분 나머지를 원래 값으로 복구한다.
  * 종료 판단: 카운터 P값을 감소시킨다. 만일 P값이 0이 아니면, 왼쪽 시프트 단계로 이동하여 다음 비트를 처리한다. 만일 P값이 0이면, 몫 계산이 끝난 것이고, n비트 몫은 레지스터 Q에, 그리고 n비트 나머지는 레지스터 A에 저장되어 있다.
 
## 6.6 실수
### 부동 소수점 표현
* 과학 표기
  * $\pm significant\times Base^{exponent}(부호\* 가수 \times 기수^{지수}$
  * $significant=mantissa=fraction$
* 10진수 과학 표기 예
  * $976,000,000,000=9.76\times 10^{11}$
  * $-0.00000000000976=9.76\times 10^{-12}$
* 2진수 예
  * $0.1101\times 2^{2}=11.010\times 2^{0}=110.10\times 2{-1}$
  * 정규화(normalize) 필요
 
### 가수 정규화
* 가수 정규화
  * ($1.bbb...b\times 2^{\pm E}$)형식이 되도록 지수 조정
  * 1.은 표현에서 생량(항상 1.0은 있는 것으로 취급)
  * 가수를 표현하는 비트 영역 최대 활용
  * 숫자 0은 모든 비트를 0으로 채움
 
![image](https://github.com/user-attachments/assets/d1948fe7-a047-4e75-8463-ab50c619311a)

### 바이어스 지수
* 바이어스 지수
  * 표현=지수+bias //지수를 양수로 변환
  * 실제 지수=표현-bias
  * 예) 지수 영역이 8비트일 때, $bias=127_{10}=0111_1111$

![image](https://github.com/user-attachments/assets/b2576616-abe6-471f-a23f-1e40539cfb84)

  * 이유: 덧셈 뺄셈을 할 때, 양수 영역에서 지수를 비교하기 위하여

![image](https://github.com/user-attachments/assets/e50f7403-91a9-4627-b290-7341278a3cec)

![image](https://github.com/user-attachments/assets/e46fca47-dad4-4f30-b052-8c6abe932fdb)

![image](https://github.com/user-attachments/assets/a59b8520-bd30-4e59-8b92-89356bc44172)

![image](https://github.com/user-attachments/assets/84f32280-65fa-42b2-8aff-8d7306982ecd)
