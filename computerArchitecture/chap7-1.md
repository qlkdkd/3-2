# 7. 명령어 집합
## 7.1. 명령어 특성

### 명령어 구성 요소
* 명령어 구성 요소: 동작코드+오퍼랜드
* 동작 코드
  * 중앙처리장치가 실행할 동작을 2진수로 표현한 코드
  * 니모닉 코드: 의미를 나타내는 기호 코드
  * 예) ADD, SUB, MUL, DIV, BR, PUSH, POP
 
* 오퍼랜드(operand)
  * 동작의 대상: 소스 오퍼랜드, 목적지 오퍼랜드, 분기목적지 주소
  * 실제
    * 레지스터: 레지스터에 이름을 부여하고, 이 레지스터 이름으로 오퍼랜드를 나타낸다. 기계어 명령어는 레지스터 번호에 해당하는 2진수로 레지스터를 표현한다.
    * 기억 장치 주소: 프로그램에서 정의한 변수는 일반적으로 기억장치에 할당된다. 어셈블리 언어는 변수 이름을 오퍼랜드로 사용하고, 기계어 명령어는 이 변수가 할당된 기억장소 주소를 오퍼랜드로 사용한다.
    * 입출력 포트: 어셈블리 언어는 입출력 포트에 부여되는 이름을 오퍼랜드로 사용하고, 기계어 명령어는 2진수 포트 번호를 오퍼랜드로 사용한다.

### 명령어 종류
* 명령어 종류
  * 데이터 전달 명령어: 레지스터, 주기억장치, 입출력 포트 쌍에 대하여 데이터를 수정하지 않고 한 장소에서 다른 장소로 데이터를 이동시키는 명령어이다. 이 그룹의 명령어는 오퍼랜드 종류와 데이터 형식에 따라 동작 코드가 다르게 정의되어야 한다.
    * A<- B
  * 데이터 처리 명령어: 산술 및 논리 연산 명령어이다. 소스 오퍼랜드의 데이터를 조작하여 목적지 오퍼랜드에 저장한다. 데이터 처리 명령어는 다양한 형식의 데이터를 처리할 수 있어야 한다. 개념이 같은 더하기 명령어라도 처리하려는 데이터 형식에 따라 동작코드를 다르게 정의해야 한다
    * A<- B op C
  * 프로그램 제어: 프로그램의 실행 순서를 변경하는 명령어 그룹이다. 프로그램 카운터의 값을 분기 목적지 주소로 변경하낟. 분기 목적지 주소를 여러가지 방법으로 표현할 수 있다.
  * * PC<- 목적지 주소
   
### 명령어 형식
* 명령어 형식
  * 명령어 비트 영역에 명령어 구성 요소를 배치한 형태
  * 동작 코드 필드, 오퍼랜드 필드
* 프로세서의 명령어 형식: 고정 길이/가변 길이 명령어 형식
* 고정 길이 명령어 형식
  * 명령어의 길이가 모두 같다.
  * 해석이 쉽고, 제어장치가 간단하다.
  * RISC(Reduced Instruction Set Computer)
* 가변 길이 명령어 형식
  * 명령어 종류별로 길이가 다르다.
  * 해석이 어렵고, 제어장치가 복잡하다.
  * CISC(Complex Instruction Set Computer)
 
### PowerPC 명령어 형식
![image](https://github.com/user-attachments/assets/94880d2b-7aee-4f36-9436-9f2ae603ddf0)
* 32비트 고정 길이 명령어 형식
* 명령어 종류에 따라 다섯 그룹의 명령어 형식 정의
* 상위 6비트는 동작 코드 필드
* 나머지 필드는 명령어 종류에 따라 의미가 다름
* RISC계열의 프로세서들은 고정 길이 명령어 형식을 가지고 있음

### Pentium 명령어 형식
![image](https://github.com/user-attachments/assets/16e8021f-2876-4446-ae54-c13a8c5579eb)
* prefix 필드는 명령어마다 앞에 붙을 수도 있고 없을 수도 있다.
* prefix 필드의 최대 길이는 4바이트
* prefix필드 다음에 명령어 필드 붙음
* 명령어 길이도 매우 가변적
* 가장 작은 명령어는 동작코드 필드만 있는 한 바이트 명령어
* 가장 긴 명령어는 prefix필드를 제외하고도 12바이트이다.
* CISC계열의 프로세스들은 가변 길이 명령어 형식을 가지고 있음

## 7.2. 주소의 수
#### 명령어 종류별 오퍼랜드
* 데이터 전달 명령어: 목적지, 소스
* 데이터 처리 명령어: 목적지, 소스1, 소스2
* 프로그램 제어 명령어: 분기 목적지

### 3-주소 명령어 형식
![image](https://github.com/user-attachments/assets/7b2ca4d8-daeb-4242-9645-379392ec6d45)

* 목적지<- 소스1 op 소스2
* $y=A \times B + C \times D$
```
MUL R1, A, B // R1<-A*B
MUL R2, C, D // R2<-C*D
ADD Y, R1, R2 // Y<-R1+R2
```
* 특징
  * 오퍼랜드를 3개 모두 표현한다
  * 명령어 길이가 길어진다
  * 프로그램을 구현하는 명령어 수가 적다
  * RISC 프로세서에서 주로 사용한다.

### 2-주소 명령어 형식
![image](https://github.com/user-attachments/assets/10701567-ddf2-41fd-9df9-4c33c432b4b1)

* 목적지<- 목적지 op 소스
![image](https://github.com/user-attachments/assets/d87f9f13-fa0f-4c8d-8361-c81042db3672)

* 특징
  * 소스 오퍼랜드 하나를 생략한다.
  * 명령어 길이가 짧아진다.
  * 프로그램을 구현하는 명령어 수가 증가한다.
  * CISC 프로세서에서 주로 사용한다.

### 1-주소 명령어 형식
![image](https://github.com/user-attachments/assets/261fb820-5535-479a-9db8-fce8149e3cb7)

![image](https://github.com/user-attachments/assets/29500278-8991-40c5-a1d6-3ac799cd53be)

* 특징
  * 누산기(AC)를 사용한다.
  * 명령어 표현에서 누산기를 생략한다.
  * 명령어의 길이가 짧다.
  * 프로그램을 구현하는 명령어의 수가 가장 많다
  * 초기 컴퓨터에서 사용하였으나, 지금은 찾아보기 힘들다.

### 0-주소 명령어 형식
* 특수 계산기에서 사용하는 명령어 형식
* 스택 연산
  * 계산식 표현
  * 후위 표기식: $Y=A\times B + C \times D$-> ($Y=AB\times CD\times +$)
* 계산 과정

![image](https://github.com/user-attachments/assets/962409fa-cffb-4129-8dbf-6557c62b5c09)

![image](https://github.com/user-attachments/assets/e8b1fb82-84ca-413e-83a3-1912710f471b)

## 7.3. 주소지정방식
* 용어
  * 오퍼랜드 필드: 명령어에 표현되어 있는 연산의 대상
  * 유효 데이터: 실제 처리되는 데이터
  * 유효 주소: 유효 데이터가 저장되어 있는 기억장치 주소
 
* 내용
  * 즉치 주소지정방식: 명령어에 유효 데이터가 들어있다
  * 직접 주소지정방식: 유효 데이터가 기억장치에 있고, 명령어는 유효 주소를 포함하고 있다.
  * 간접 주소지정방식: 유효 데이터가 기억장치에 있고, 명령어는 유효주소의 주소를 포함하고 있다.
  * 레지스터 주소지정방식: 유효 데이터가 레지스터에 저장되어 있다. 명령어는 레지스터 번호를 포함한다.
  * 레지스터 간접 주소지정방식: 유효 데이터가 기억 장치에 있고, 명령어는 유효 주소를 저장하고 있는 레지스터 번호를 포함한다.
  * 변위 주소지정방식: 명령어에 포함된 2진수와 레지스터의 값을 더하여 유효 주소를 계산한다.
 
* 주소지정방식: 오퍼랜드 필드마다 별도 적용
* 표기법
  * A: 명령어에 표현된 주기억장치 주소
  * Mem(A): 주기억장치 A번지에 저장된 값
  * R: 레지스터 번호
  * (R): 레지스터 R에 저장되어 있는 값
  * EA: 유효 주소. 유효 데이터가 저장되어 있는 기억장치 주소
 
### 즉치 주소지정방식
![image](https://github.com/user-attachments/assets/d1ef45c1-3313-4e44-b164-c4424e07a76c)

* 즉치 데이터
  * 명령어에 유효 데이터 포함
  * 명령어를 실행할 때 기억장치를 액세스할 필요가 없다.
  * 유효 데이터의 표현 범위가 오퍼랜드 필드 크기에 제한받는다.
 
* 명령어 예
  * 1-주소지정방식: ADDI #20 // AC<-AC+20
  * 2-주소지정방식: LDI R0, #12 // R0<-12
 
![image](https://github.com/user-attachments/assets/5c875248-c420-451e-847d-9909ce7bed45)

### 직접 주소지정방식
![image](https://github.com/user-attachments/assets/044d0644-214d-426e-bf3a-5fab276520df)

* A는 기억장치 주소이므로 부호없는 수이다.
* 명령어를 인출한 후, 명령어 실행 단계에서 유효 데이터를 가져오기 위하여 기억장치를 한 번 액세스해야 한다.
* 명령어에 포함된 오퍼랜드 필드의 길이는 기억장치 버스 폭과 같아야 한다. 따라서 기억장치의 용량이 커질수록 명령어 길이도 증가한다. 예를 들어 기억장치 용량이 1MB일때, A의 길이는 20비트이다.

* 명령어 예
  * 1-주소지정방식: ADD#20// AC<-AC+Mem(20)
  * 2-주소지정방식: LD R0, #1200// R0<-Mem(1200)

![image](https://github.com/user-attachments/assets/eff02262-3a7d-47c5-b780-1c04f1b44c13)

### 간접 주소지정방식
![image](https://github.com/user-attachments/assets/4f496a9d-3d74-4247-a047-a1468a3fdf44)

* 간접주소지정방식은 그림 6-10과 같이 명령어의 오퍼랜드 필드에 유효 주소가 저장되어 있는 기억 장소의 주소가 저장되어 있고, 기억장치에서 유효 주소를 찾아 이 주소로 기억장치를 한 번 더 액세스해야 실제로 처리할 유효 데이터를 찾을 수 있다.
  * A는 기억장치 주소이므로 부호 없는 수이다.
  * Mem(A)에 기억장치 주소가 저장되어 있고, 이것이 유효 주소이다.
  * 명령어를 인출한 후, 명령어 실행단계에서 유효 데이터를 가져오기 위하여 기억장치를 두 번 액세스해야 한다.
  * 명령어에 포함되어 있는 오퍼랜드 필드 길이는 주소 버스 폭과 같아야 한다. 기억장치 용량이 커질수록 명령어 길이도 증가한다.
 
* 명령어 예
  * 1-주소지정방식: ADDID #20 //AC<-AC_Mem(Mem(20))
  * 2-주소지정방식: LDID R0, #1200 //R0<-Mem(Mem(1200))
 
![image](https://github.com/user-attachments/assets/6540edc4-eb06-4bd9-8bcc-2e3ac6befd9a)

### 레지스터 주소지정방식
![image](https://github.com/user-attachments/assets/575eb78c-7ea1-45d0-9f1f-60dd49f74983)

* 레지스터 주소지정방식은 그림 6-11과 같이 명령어의 오퍼랜드 필드가 레지스터 중 하나를 지시한다. 레지스터 값이 처리할 유효 데이터이다.
  * 유효 데이터가 기억장치가 아닌 레지스터에 저장되어 있다.
  * 기억장치를 사용하지 않으므로, 유효 주소 개념이 없다.
  * 레지스터 수는 기억장치 용량에 비하여 매우 작다. R은 레지스터 중 하나를 지칭하는 레지스터 번호이므로, 기억장치 주소보다 길이가 짧다. 프로세스의 레지스터가 32개일 때, R의 비트는 5비트이다. 따라서 명령어 전체 길이도 감소한다.
  * 실행단계에서 유효 데이터를 가져오기 위하여 기억장치를 액세스할 필요가 없다. 따라서 유효 데이터가 기억장치에 저장되어 있는 명령어보다 실행속도가 빠르다.
 
* 명령어 예
  * 2-주소지정방식: LD R0, #1200 //R0<-Mem(1200)
  * 2-주소지정방식: ADD R0, R1 //R0<-R0+R1
  * 3-주소지정방식: ADD R0, R1, R2 //R0<-R1+R2
 
![image](https://github.com/user-attachments/assets/c3bee80b-df8a-4e01-b9e2-4b6bd929b91f)

### 레지스터 간접 주소지정방식
![image](https://github.com/user-attachments/assets/5854b0b5-ef81-4c04-8469-8494fda368ac)

* 레지스터 간접주소지정방식은 레지스터 주소지정방식과 간접 주소지정방식을 합친 것이다. 그림 6-12와 같이 명령어의 오퍼랜드 필드는 레지스터를 지정하고, 이 레지스터의 값을 유효 주소로 사용하여 기억 장치를 액세스하고, 그 안에 유효 데이터가 저장되어 있다.
  * 유효 주소가 레지스터에 저장되어 있다. 유효 주소는 (R)이고, 유효 데이터는 Mem((R))이다.
  * 실행 단계에서 유효 데이터를 가져오기 위하여 기억장치를 한 번 액세스한다.
  * R은 레지스터 번호이므로, 기억장치 주소에 비하여 길이가 짧다. 명령어 길이가 짧으면서도 기억장치를 액세스할 수 있다는 장점이 있다.
 
![image](https://github.com/user-attachments/assets/9ae2b49a-9760-4daf-a368-47950df5c5bb)

### 변위 주소지정 방식

![image](https://github.com/user-attachments/assets/8110010f-80db-4b2b-8853-d51c3ae3552f)

* 유효 주소 = (R)+A
* 부호 확장 덧셈 예
  * 기억장치 주소: 16비트(기억장치 공간 64KB)
  * 레지스터 길이: 16비트
  * 명령어 주소 필드 A: 12비트
  * 유효 주소: (R)(16비트)+A(12비트)
 
* 종류
  * 상대주소지정방식
  * 베이스 레지스터 주소지정방식
  * 인덱싱
 
### 상대주소지정방식

![image](https://github.com/user-attachments/assets/c7338f19-58b4-4cb1-9c48-1d012e79d822)

* 상대주소지정방식
  * 분기 목적지=PC+A(정수, 부호 확장)
  * (조건)분기명령어, 서브루틴 호출 명령어
 
### 베이스 레지스터 주소지정방식
* Base Register: 스택의 기준점 지정
* 유효 주소=(BR)+A(정수, 부호 확장 계산)
* 기준점의 위 아래 액세스 가능

![image](https://github.com/user-attachments/assets/53a34568-c8f5-4cdc-be44-547550eda223)

### 인덱싱
* 유효주소=(Index Register)+A(부호 없는 수, 부호 확장 계산)
* 자동 인덱싱(auto indexing)
  * Pre-indexing: 인덱스 레지스터 갱신 후 기억장치 액세스
  * Post-indexing: 기억장치 액세스 후 인덱스 레지스터 갱신
 
![image](https://github.com/user-attachments/assets/48bafbde-207e-4b7b-a44f-dad84aef4f65)
